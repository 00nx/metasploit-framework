# -*- coding: binary -*-

#
# This class implements an override for RubySMB's default authentication method to instead
# use a kerberos authenticator
#
module Msf::Exploit::Remote::DCERPC::KerberosAuthentication
  # @param [Msf::Exploit::Remote::Kerberos::ServiceAuthenticator::SMB] kerberos_authenticator The authenticator to make the required Kerberos requests
  def kerberos_authenticator=(kerberos_authenticator)
    @kerberos_authenticator = kerberos_authenticator
  end

  def auth_provider_init
    kerberos_result = @kerberos_authenticator.authenticate
    @application_key = @session_key = kerberos_result[:session_key]
    @client_sequence_number = kerberos_result[:client_sequence_number]
    kerberos_result[:security_blob]
  end

  def auth_provider_encrypt_and_sign(dcerpc_req)
    auth_pad_length = get_auth_padding_length(dcerpc_req.stub.to_binary_s.length)
    plain_stub = dcerpc_req.stub.to_binary_s + "\x00" * auth_pad_length
    emessage, header_length, krb_pad_length = self.krb_encryptor.encrypt_and_increment(plain_stub)

    encrypted_stub = emessage[header_length..-1]
    signature = emessage[0,header_length]
    dcerpc_req.sec_trailer.auth_pad_length = auth_pad_length
    set_encrypted_packet(dcerpc_req, encrypted_stub, auth_pad_length)
    set_signature_on_packet(dcerpc_req, signature)
  end

  def auth_provider_decrypt_and_verify(dcerpc_response)
    encrypted_stub = get_response_full_stub(dcerpc_response)
    signature = dcerpc_response.auth_value
    data = signature + encrypted_stub

    begin
      result = self.krb_encryptor.decrypt_and_verify(data)
    rescue Rex::Proto::Kerberos::Model::Error::KerberosError
      return false
    end
    set_decrypted_packet(dcerpc_response, result)
  end

  def build_ap_rep(session_key, sequence_number)
    pvno = Rex::Proto::Kerberos::Model::VERSION
    msg_type = Rex::Proto::Kerberos::Model::AP_REP
    ctime = Time.now.utc 
    cusec = ctime&.usec

    encrypted_part = Rex::Proto::Kerberos::Model::EncApRepPart.new(
      ctime: ctime,
      cusec: cusec,
      sequence_number: sequence_number,
      enc_key_usage: Rex::Proto::Kerberos::Crypto::KeyUsage::AP_REP_ENCPART
    )
    enc_aprep = Rex::Proto::Kerberos::Model::EncryptedData.new(
      etype: session_key.type,
      cipher: encrypted_part.encrypt(session_key.type, session_key.value)
    )

    Rex::Proto::Kerberos::Model::ApRep.new(
      pvno: pvno,
      msg_type: msg_type,
      enc_part: enc_aprep
    )
  end

  def auth_provider_complete_handshake(response, options)    
      #@kerberos_authenticator.validate_response!(response.auth_value)
      gss_api = OpenSSL::ASN1.decode(response.auth_value)
      security_blob = ::RubySMB::Gss.asn1dig(gss_api, 0, 2, 0)&.value
      ap_rep = Rex::Proto::Kerberos::Model::ApRep.decode(security_blob)
      ap_rep_enc_part = ap_rep.decrypt_enc_part(@session_key.value)
      server_sequence_number = ap_rep_enc_part.sequence_number
      # Now complete the handshake - see [MS-KILE] 3.4.5.1 - https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-kile/190ab8de-dc42-49cf-bf1b-ea5705b7a087
      response_ap_rep = build_ap_rep(@session_key, server_sequence_number)

      wrapped_ap_rep = OpenSSL::ASN1::ASN1Data.new([
          OpenSSL::ASN1::Sequence.new([
            OpenSSL::ASN1::ASN1Data.new([
              OpenSSL::ASN1::OctetString(response_ap_rep.encode)
            ], 2, :CONTEXT_SPECIFIC)
          ])
        ], 1, :CONTEXT_SPECIFIC).to_der

      alter_ctx = RubySMB::Dcerpc::Bind.new(options)
      # Alter context (3rd message) is identical to Bind requests by definition
      alter_ctx.pdu_header.ptype = RubySMB::Dcerpc::PTypes::ALTER_CONTEXT
      alter_ctx.pdu_header.call_id = @call_id

      add_auth_verifier(alter_ctx, wrapped_ap_rep)

      send_packet(alter_ctx)

      begin
        dcerpc_response = recv_struct(RubySMB::Dcerpc::AlterContextResp)
      rescue RubySMB::Dcerpc::Error::InvalidPacket
        raise RubySMB::Dcerpc::Error::BindError # raise the more context-specific BindError
      end

      self.krb_encryptor = @kerberos_authenticator.get_message_encryptor(ap_rep_enc_part.subkey, 
                                                                                  @client_sequence_number,
                                                                                  server_sequence_number)
      # Set the session key value on the parent class - needed for decrypting attribute values in e.g. DRSR
      @session_key = ap_rep_enc_part.subkey.value
  end

  def get_auth_padding_length(plaintext_len)
    (4 - (plaintext_len % 4)) % 4
  end

  attr_accessor :krb_encryptor
end
