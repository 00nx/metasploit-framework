# -*- coding: binary -*-

module Msf
  class Exploit
    class Remote
      module HTTP
        # This module provides a way of interacting with Apache NiFi installations
        module Nifi
          include Msf::Exploit::Remote::HttpClient
          include Msf::Exploit::Remote::HTTP::Nifi::Auth
          include Msf::Exploit::Remote::HTTP::Nifi::Processor
          include Msf::Exploit::Remote::HTTP::Nifi::Dbconnectionpool

          def initialize(info = {})
            super

            register_options(
              [
                Msf::Opt::RPORT(8443),
                Msf::OptString.new('TARGETURI', [ true, 'The URI of the Apache NiFi Application', '/']),
                Msf::OptString.new('USERNAME', [false, 'Username to authenticate with']),
                Msf::OptString.new('PASSWORD', [false, 'Password to authenticate with']),
                Msf::OptString.new('BEARER-TOKEN', [false, 'JWT authenticate with']),
              ], Msf::Exploit::Remote::HTTP::Nifi
            )

            register_advanced_options([
              Msf::OptBool.new('SSL', [true, 'Negotiate SSL connection', true])
            ])
          end

          # Find the version number of the Apache NiFi system based on JS calls on the nifi/ page.
          #
          # @return [Gem::Version] version number of the system, or nil on error
          def get_version
            res = send_request_cgi!(
              'uri' => normalize_uri(target_uri.path, 'nifi/')
            )

            fail_with(Failure::Unreachable, "#{peer} - Could not connect to web service - no response") if res.nil?
            fail_with(Failure::UnexpectedReply, "#{peer} - Unexpected Respones Code (response code: #{res.code})") unless res.code == 200

            return Rex::Version.new(Regexp.last_match(1)) if res.body =~ %r{js/nf/nf-namespace\.js\?([\d.]*)">}

            nil
          end

          # Checks the API response to see if its what is expected and returns a valid result.
          #
          # @param description [String] The description of what is being checked
          # @param response [String] The response to check
          # @param expected_response_code [Int] HTTP Response code that is expected
          # @param item [Int] The item in the JSON blob that is needed
          # @return the value of the item from the JSON blob from the response
          def check_response(description, response, expected_response_code, item = '')
            # Check that response was received
            fail_with(Msf::Module::Failure::Unreachable, "Unable to retrieve HTTP response from API when #{description}") unless response
            # Check that response code was expected
            if response.code != expected_response_code
              fail_with(Msf::Module::Failure::UnexpectedReply,
                        "Unexpected HTTP response code from API when #{description} " \
                        "(received #{response.code}, expected #{expected_response_code})")
            end
            # Check that item can be retrieved
            return if item.empty?

            body = response.get_json_document
            unless body.key?(item)
              fail_with(Msf::Module::Failure::UnexpectedReply, "Unable to retrieve #{item} from HTTP response when #{description}")
            end
            body[item]
          end

          # Fetch the root process group's UUID
          #
          # @param token [String] The bearer token from a valid login
          # @return [String] The UUID of the root process group
          def fetch_root_process_group(token)
            opts = {
              'method' => 'GET',
              'uri' => normalize_uri(target_uri.path, 'nifi-api', 'process-groups', 'root')
            }
            opts['headers'] = { 'Authorization' => "Bearer #{token}" } if token
            response = send_request_cgi(opts)
            check_response('GETting root process group', response, 200, 'id')
          end
        end
      end
    end
  end
end
