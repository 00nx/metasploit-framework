# -*- coding: binary -*-

#
# This mixin is a simplistic implementation of X11
#
# Wireshark dissector: https://wiki.wireshark.org/X11
#

module Msf::Exploit::Remote::X11

  class X11VISUALTYPE < BinData::Record
    endian :little
    uint32 :visualid
    uint8 :class
    uint8 :bits_per_rgb_value
    uint16 :colormap_entries
    uint32 :red_mask
    uint32 :green_mask
    uint32 :blue_mask
    uint32 :unused
  end

  class X11DEPTHDETAIL < BinData::Record
    endian :little
    uint8 :screen_detail_depth
    uint8 :unused
    uint16 :screen_depth_detail_visualtypes_numbers
    uint32 :unused
    array :depth_detail,
          type: :x11visualtype,
          initial_length: screen_depth_detail_visualtypes_numbers
  end

  class X11PIXMAPFORMAT < BinData::Record
    endian :little
    uint8 :depth
    uint8 :bits_per_pixel
    uint8 :scanline_pad
    uint8 :unused
    uint32 :unused1
  end

  class X11CONNECTION < BinData::Record
    endian :little
    uint8 :success # 8bit boolean, \x01 == true \x00 == false
    uint8 :unused
    uint16 :protocol_version_major
    uint16 :protocol_version_minor
    uint16 :reply_length
    uint32 :release_number
    uint32 :resource_id_base
    uint32 :resource_id_mask
    uint32 :motion_buffer_size
    uint16 :vendor_length
    uint16 :maximum_request_length
    uint8 :number_of_screens_in_root
    uint8 :number_of_formats_in_pixmap_formats
    uint8 :image_byte_order
    uint8 :bitmap_format_bit_order
    uint8 :bitmap_format_scanline_unit
    uint8 :bitmap_format_scanline_pad
    uint8 :min_keycode
    uint8 :max_keycode
    uint32 :unused2
    string :vendor, read_length: :vendor_length
    array :pixmap_formats,
          type: :x11pixmapformat,
          initial_length: :number_of_formats_in_pixmap_formats

    # screen subsection
    uint32 :screen_root
    uint32 :screen_default_colormap
    uint32 :screen_white_pixel
    uint32 :screen_black_pixel
    uint32 :screen_current_input_masks
    uint16 :screen_width_in_pixels
    uint16 :screen_height_in_pixels
    uint16 :screen_width_in_millimeters
    uint16 :screen_height_in_millimeters
    uint16 :screen_min_installed_maps
    uint16 :screen_max_installed_maps
    uint32 :screen_root_visual
    uint8 :screen_backing_stores
    uint8 :screen_save_unders # 8bit boolean, \x01 == true \x00 == false
    uint8 :screen_root_depth
    uint8 :screen_allowed_depths_len
    array :depth_detail,
          type: :x11depthdetail,
          initial_length: :screen_allowed_depths_len
  end

  class X11QUERYEXTENSIONRESPONSE < BinData::Record
    endian :little
    uint8 :reply
    uint8 :unused
    uint16 :sequence_number # QueryExtension
    uint32 :reply_length
    uint8 :present # 8bit boolean, \x01 == true \x00 == false
    uint8 :major_opcode # this is the ID of the extension
    uint8 :first_event
    uint8 :first_error
  end

  class X11GETPROPERTYRESPONSE < BinData::Record
    endian :little
    uint8 :reply
    uint8 :format
    uint16 :sequence_number # GetProperty
    uint32 :reply_length
    uint32 :get_property_type # 8bit boolean, \x01 == true \x00 == false
    uint32 :bytes_after
    uint32 :value_length
    uint32 :unused
    uint32 :unused1
    uint32 :unused2
    string :value_data, read_length: -> { value_length }
  end

  class X11XKBKEYTYPE < BinData::Record
    endian :little
    uint8 :mods_mask
    uint8 :mods_mods
    uint16 :mods_vmods
    uint8 :num_levels
    uint8 :n_map_entries
    uint8 :has_preserve
    uint8 :unused
    # next we have a list of X11XKBKEYMAPENTRY, length is :n_map_entries
    # next we have a list of X11XKBKEYSYMENTRY
    # next we have a list of X11XKBKEYMODMAP
  end

  class X11XKEYBOARDGETMAP < BinData::Record
    endian :little
    uint8 :reply
    uint8 :device_id
    uint16 :sequence_number # xkb-GetMap
    uint32 :reply_length
    uint16 :unused
    uint8 :min_key_code
    uint8 :max_key_code
    bit1 :present_key_types
    bit1 :present_key_syms
    bit1 :present_modifier_map
    bit1 :present_explicit_components
    bit1 :present_key_actions
    bit1 :present_key_behaviors
    bit1 :present_virtual_mods
    bit1 :present_virtual_mod_map
    uint8 :first_type
    uint8 :n_types
    uint8 :total_types
    uint8 :first_key_sym
    uint8 :total_sym
    uint8 :n_key_sym
    uint8 :first_key_action
    uint8 :total_key_action
    uint8 :n_key_action
    uint8 :first_key_behavior
    uint8 :n_key_behavior # yes this order is not like the previous
    uint8 :total_key_behavior
    uint8 :first_key_explicit
    uint8 :n_key_explicit
    uint8 :total_key_explicit
    uint8 :first_mod_map_key
    uint8 :n_mod_map_key
    uint8 :total_mod_map_key
    uint8 :first_vmod_map_key
    uint8 :n_vmod_map_key
    uint8 :total_vmod_map_key
    uint8 :unused1
    uint8 :virtual_mods # bit array
    # next we have a list of X11XKBKEYTYPE, length is :total_types
    array :key_types,
          type: X11XKBKEYTYPE,
          initial_length: total_types
  end

  class X11XKBKEYMAPENTRY < BinData::Record
    endian :little
    uint8 :active
    uint8 :mods_mask # bit array, shift, lock, control, 1, 2, 3, 4, 5
    uint8 :level
    uint8 :mods_mods # bit array, shift, lock, control, 1, 2, 3, 4, 5
    uint16 :mods_vmods # bit array, 0-15
    uint16 :unused
  end

  class X11XKBKEYSYMENTRY < BinData::Record
    endian :little
    uint32 :kt_index
    uint8 :group_info
    uint8 :width
    uint16 :n_syms
    # next we have a list of syms, length is n_syms

  end

  class X11XKBSYM < BinData::Record
    endian :little
    uint32 :syms
  end

  class X11XKBKEYMODMAP < BinData::Record
    endian :little
    uint8 :keycode
    uint8 :mods # bit array, shift, lock, control, 1, 2, 3, 4, 5
  end

  def process_initial_connection_response(packet)
    # print_packet(packet)
    success = packet[0]
    if success == "\x01"
      print_good('Successly established X11 connection')
    else
      fail_with(Msf::Module::Failure::UnexpectedReply, 'Failed to establish an X11 connection')
    end
    major_version = packet[2].unpack('C').first
    vprint_status("Major Version: #{major_version}")
    minor_version = packet[4].unpack('C').first
    vprint_status("Minor Version: #{minor_version}")
    vendor_str_len = packet[24].unpack('C').first
    vprint_status("Vendor: #{packet[40, vendor_str_len]}")
    screen_width = packet[136, 2].unpack('S<').first
    screen_height = packet[138, 2].unpack('S<').first
    vprint_status("Screen Resolution: #{screen_width}x#{screen_height}")
    resource_id = packet[12, 4]
    vprint_status("Resource ID: #{resource_id.inspect}")
    resource_id
  end
end
