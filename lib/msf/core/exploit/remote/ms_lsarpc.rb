###
#
# This mixin provides methods to open, and close policy handles, and to query policy info on the remote SMB server.
#
# -*- coding: binary -*-

module Msf

  module Exploit::Remote::MsLsarpc

    include Msf::Exploit::Remote::SMB::Client::Ipc

    class MsLsarpcError < StandardError; end
    class MsLsarpcConnectionError < MsLsarpcError; end
    class MsLsarpcAuthenticationError < MsLsarpcError; end
    class MsLsarpcUnexpectedReplyError < MsLsarpcError; end

    LSA_UUID        = '12345778-1234-abcd-ef00-0123456789ab'.freeze
    LSA_VERS        = '0.0'.freeze
    LSARPC_ENDPOINT = RubySMB::Dcerpc::Lsarpc.freeze

    # The currently connected LSARPC pipe
    attr_reader :lsarpc_pipe

    def map_security_principal_to_string(security_principal)
      case security_principal
      when 1
        'User'
      when 2
        'Group'
      when 3
        'Domain'
      when 4
        'Alias'
      when 5
        'Well-Known Group'
      when 6
        'Deleted Account'
      when 7
        'Invalid'
      when 8
        'Unknown'
      when '9'
        'Computer'
      when 10
        'Label'
      else
        'Unknown - Not a valid Security Principal'
      end
    end

    def open_policy2(impersonation_level, security_context_tracking_mode, access_mask)
      self.lsarpc_pipe.lsar_open_policy2(
        system_name: simple.peerhost,
        object_attributes: {
          security_quality_of_service: {
            impersonation_level: impersonation_level,
            security_context_tracking_mode: security_context_tracking_mode
          }
        },
        access_mask: access_mask
      )
    end

    def query_information_policy(policy_handle, information_class)
      self.lsarpc_pipe.lsar_query_information_policy(
        policy_handle: policy_handle,
        information_class: information_class
      )
    end

    def lookup_sids(policy_handle, sids, lookup_level)
      sids = [sids] unless sids.is_a?(Array)

      self.lsarpc_pipe.lsar_lookup_sids(
        policy_handle: policy_handle,
        sids: sids,
        lookup_level: lookup_level
      )
    end

    def close_policy(policy_handle)
      self.lsarpc_pipe.lsar_close_handle(
        policy_handle: policy_handle
      ) if (self.lsarpc_pipe && policy_handle)
    end

    def disconnect_lsarpc
      begin
        self.lsarpc_pipe.close if self.lsarpc_pipe&.is_connected?
      rescue RubySMB::Error::UnexpectedStatusCode => e
        wlog e
      end
    end

    module_function

    def connect_lsarpc(tree)
      begin
        vprint_status('Connecting to LSARPC')
        self.lsarpc_pipe = tree.open_file(filename: 'LSARPC', write: true, read: true)

        raise MsLsarpcConnectionError.new('Could not open LSARPC pipe on remote SMB server.') unless lsarpc_pipe

        self.lsarpc_pipe.extend(LSARPC_ENDPOINT) unless lsarpc_pipe.is_a?(LSARPC_ENDPOINT)

        vprint_status('Binding to \\LSARPC...')
        self.lsarpc_pipe.bind(endpoint: LSARPC_ENDPOINT)
        vprint_good('Bound to \\LSARPC')

        self.lsarpc_pipe
      rescue RubySMB::Dcerpc::Error::FaultError => e
        elog(e.message, error: e)
        raise MsLsarpcUnexpectedReplyError, "Connection failed (DCERPC fault: #{e.status_name})"
      end
    end

    protected

    attr_writer :lsarpc_pipe

  end

end
